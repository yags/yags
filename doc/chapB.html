<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (YAGS) - Appendix B: YAGS Functions Reference</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chapB"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapA.html">A</a>  <a href="chapB.html">B</a>  <a href="chapC.html">C</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chapA.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapC.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"></p>
<p><a id="X79733EF080AF012A" name="X79733EF080AF012A"></a></p>
<div class="ChapSects"><a href="chapB.html#X79733EF080AF012A">B <span class="Heading"><strong class="pkg">YAGS</strong> Functions Reference</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X864799C9864799C9">B.1 <span class="Heading">A</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8332EA8C8406B570">B.1-1 AddEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7CF12BD58616E814">B.1-2 AddVerticesByAdjacencies</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X85A84B247E3DE0C6">B.1-3 Adjacencies</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7CEFD50D868B8EEB">B.1-4 Adjacency</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B38E7137B6E12D6">B.1-5 AdjMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X83C068317E95A402">B.1-6 AGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X81B477F881CB7FD6">B.1-7 AntennaGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X87677B0787B4461A">B.1-8 AutomorphismGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X7FD70CD27FD70CD2">B.2 <span class="Heading">B</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X86C78160854C7F30">B.2-1 Backtrack</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7A625FDE7D726FAB">B.2-2 BacktrackBag</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F2566527F566D99">B.2-3 Basement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8643BBC5802677DE">B.2-4 BoundaryVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8724BE6381EA1A23">B.2-5 BoxProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B338162824A09E3">B.2-6 BoxTimesProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7A06294F8001BBC8">B.2-7 BullGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X78A77FDB78A77FDB">B.3 <span class="Heading">C</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7AB3B70B7B5F8B4E">B.3-1 CayleyGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X843994627A0728F1">B.3-2 ChairGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8301C7647DF897A1">B.3-3 Circulant</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DC2B392863DC66C">B.3-4 ClawGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X80671C3A7AAF7B3F">B.3-5 CliqueGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X78427A8B81FEB457">B.3-6 CliqueNumber</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7AA94AAB7961CEC0">B.3-7 Cliques</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X80444D068708D026">B.3-8 ClockworkGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8091AC40834A0801">B.3-9 ComplementGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8350EBF38416F1F5">B.3-10 CompleteBipartiteGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7A18A66783A3EA09">B.3-11 CompleteGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7839FF457E264FE1">B.3-12 CompletelyParedGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B19862D7C5D5A92">B.3-13 CompleteMultipartiteGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C0053187FFA2F57">B.3-14 CompletesOfGivenOrder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DA501097D22881C">B.3-15 Composition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X822975FC7F646FE5">B.3-16 Cone</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7945A3B47D94FA49">B.3-17 ConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7ACA1C6F7BB211C4">B.3-18 ConnectedGraphsOfGivenOrder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84E3985A8700B302">B.3-19 Coordinates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84873D6E809669D2">B.3-20 CopyCoordinates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7A907C8C7B5CA8B7">B.3-21 CopyGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X79F9336684F71FDE">B.3-22 Cube</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C029AA28008AEE9">B.3-23 CubeGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F6EC0AE81531C3C">B.3-24 CycleGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X865BCD6C80C3E48E">B.3-25 CylinderGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X8141368181413681">B.4 <span class="Heading">D</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F3EDB5C844C33FE">B.4-1 DartGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X783AC7917B34BEEB">B.4-2 DeclareQtfyProperty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X822BD6B9862D6325">B.4-3 DFSTree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7AB7F57C832586ED">B.4-4 Diameter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84CE76487939DD04">B.4-5 DiamondGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X867DF890879C4CD5">B.4-6 DiscreteGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B00BD6C843CFA42">B.4-7 DisjointUnion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C3CB921842888BE">B.4-8 Distance</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7ADA443D7FBDD1A5">B.4-9 Distances</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C8F3D3385BF41DA">B.4-10 DistanceGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F44B86582CCC23D">B.4-11 DistanceMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X845639757F540AF7">B.4-12 DistanceSet</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X81A6D8FE876EB3BE">B.4-13 Dodecahedron</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7E8FE6A887FEFED1">B.4-14 DominatedVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F28DFDE83BB127C">B.4-15 DominoGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DF9F3AD86602DFC">B.4-16 Draw</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C9C16068556896D">B.4-17 DumpObject</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X8631458886314588">B.5 <span class="Heading">E</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7ECEE52778A8C925">B.5-1 EasyExec</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X807111A07D9E4838">B.5-2 Eccentricity</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X805DA3C47BF09BD1">B.5-3 Edges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D8CF4F57FC21A97">B.5-4 EmptyGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7E1A57287D9C4ECE">B.5-5 EquivalenceRepresentatives</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X805A4A907A37EADE">B.5-6 ExportGraph6</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X7FA1D0937FA1D093">B.6 <span class="Heading">F</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X87CA7A5782928649">B.6-1 FanGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DC9D4FA8791956D">B.6-2 FishGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X78D1A39A78D1A39A">B.7 <span class="Heading">G</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C2D6F35838052F5">B.7-1 GemGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84E213C9801D1558">B.7-2 Girth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B335342839E5146">B.7-3 Graph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84BA39B986A7A8F7">B.7-4 GraphAttributeStatistics</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DE40F478257F31A">B.7-5 Graph6ToGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8522B1957D17741E">B.7-6 GraphByAdjacencies</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F2479B8805852DC">B.7-7 GraphByAdjMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7CDF55C37DA5F76B">B.7-8 GraphByCompleteCover</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X82FE32A97F0F049F">B.7-9 GraphByEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X87040937831AA788">B.7-10 GraphByRelation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X790CBDC282E6FEA1">B.7-11 GraphByWalks</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D06ED35855A69E1">B.7-12 GraphCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X815691877F8C800C">B.7-13 Graphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F66DFB17CC3B2D9">B.7-14 GraphsOfGivenOrder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7E8B61AD787C430F">B.7-15 GraphSum</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C5F2B6D86D1DCF5">B.7-16 GraphToGraph6</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8661587880C12114">B.7-17 GraphToRaw</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X793E67DD83402749">B.7-18 GraphUpdateFromRaw</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X78BA06B387DA3279">B.7-19 GroupGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X81DA524381DA5243">B.8 <span class="Heading">H</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X82276E097B77591E">B.8-1 HararyToMcKay</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7FA941E678EAA379">B.8-2 HouseGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X86AA214A86AA214A">B.9 <span class="Heading">I</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X83E0EF8F7CCD6979">B.9-1 Icosahedron</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DF0F8C079D7D07D">B.9-2 ImportGraph6</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8688B93F7AEF7BB9">B.9-3 ImportGraph6Iterator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X87BDB89B7AAFE8AD">B.9-4 in</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D9F576185C58545">B.9-5 InducedSubgraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X78318B95813CAA26">B.9-6 InNeigh</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F43E2F0802FD790">B.9-7 InteriorVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X827067C078A10B24">B.9-8 IntersectionGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X80FF64FC7E750046">B.9-9 IsBoolean</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X78F70A8B7C72464C">B.9-10 IsCliqueGated</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X822B38D686BC1D2D">B.9-11 IsCliqueHelly</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8563061F83E10A23">B.9-12 IsCompactSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D689F21828A4278">B.9-13 IsComplete</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7BA6EF9F80968CD8">B.9-14 IsCompleteGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D03ACD07C167E0F">B.9-15 IsDiamondFree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F50265D789C602C">B.9-16 IsEdge</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X79CBEA7386509498">B.9-17 IsIsomorphicGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8219D43086F60B2E">B.9-18 IsListOfPositiveIntegers</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X782871638792F4F5">B.9-19 IsLocallyConstant</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7ACED06884FBC782">B.9-20 IsLocallyH</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F9F4622817E9AFB">B.9-21 IsLoopless</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X80F38E797C303471">B.9-22 IsoMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D702EA087C1C5EF">B.9-23 IsoMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8278D52F856A179D">B.9-24 IsOriented</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D8E63A7824037CC">B.9-25 IsSimple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8393259C7C8C4B73">B.9-26 IsSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DD8D1A185EBE865">B.9-27 IsTournament</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7CC7E10386094A61">B.9-28 IsTransitiveTournament</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X872108F17D8F264D">B.9-29 IsUndirected</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X7F3AB4517F3AB451">B.10 <span class="Heading">J</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7A4036667F52738C">B.10-1 JohnsonGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7870C5F085DD4D77">B.10-2 Join</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X784AC758784AC758">B.11 <span class="Heading">K</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X854EB85A7F08DE43">B.11-1 KiteGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X81AC8E0281AC8E02">B.12 <span class="Heading">L</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F3242BE87F58573">B.12-1 LineGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X799C11E27D07C337">B.12-2 Link</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X86BF290E79C75374">B.12-3 Links</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7BD734CC859CDF53">B.12-4 LooplessGraphs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X86DCFD0B86DCFD0B">B.13 <span class="Heading">M</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B28B2D07DA68CB0">B.13-1 MaxDegree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X865609F480A1A9EC">B.13-2 MinDegree</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X7F4C68107F4C6810">B.14 <span class="Heading">N</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7E3E7CEC812067E6">B.14-1 NextIsoMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X82361F6E8718C1CA">B.14-2 NextPropertyMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X83ADC7C07E618A7B">B.14-3 NumberOfCliques</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DB0309583D20862">B.14-4 NumberOfConnectedComponents</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X783C1B19783C1B19">B.15 <span class="Heading">O</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B1FCFC979757FED">B.15-1 OctahedralGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84BE285087AAC1F7">B.15-2 Octahedron</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84F59A2687C62763">B.15-3 Order</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B386D5B7E8A9E00">B.15-4 Orientations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7A5467E379CD8001">B.15-5 OrientedGraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7997AFF078E0909F">B.15-6 OutNeigh</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X80EC9BC680EC9BC6">B.16 <span class="Heading">P</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D97312484370E54">B.16-1 PaleyTournament</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8476F4887F0992F4">B.16-2 ParachuteGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7D013DE67ABF6A4F">B.16-3 ParapluieGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C3B877A84E18B53">B.16-4 ParedGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X815055168405B7F0">B.16-5 PathGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7E2AACE87CE0B493">B.16-6 PawGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X823F43217A6C375D">B.16-7 PetersenGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7961543D839F0387">B.16-8 PowerGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C5862667E11AFD8">B.16-9 PropertyMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F37CF7686868B0C">B.16-10 PropertyMorphisms</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X879CE8CF879CE8CF">B.17 <span class="Heading">Q</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84213A807DDB5EAF">B.17-1 QtfyIsSimple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7ED131997AF10A25">B.17-2 QuadraticRingGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X783CA3E384E13157">B.17-3 QuotientGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X7E0C7DD47E0C7DD4">B.18 <span class="Heading">R</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7BA7762D847502C7">B.18-1 Radius</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X84C9FC4078146520">B.18-2 RandomCirculant</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7E3304077D162512">B.18-3 RandomGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8675AB097F4155AF">B.18-4 RandomPermutation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X811BD56879A9FDA4">B.18-5 RandomSubset</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X815BF58E81DD91B8">B.18-6 RandomlyPermuted</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X826C69387F3EB83C">B.18-7 RemoveEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X835737627FD4FE21">B.18-8 RemoveVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B944F3286DE401F">B.18-9 RGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DAEE13082F5EA2D">B.18-10 RingGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X797C0EDD797C0EDD">B.19 <span class="Heading">S</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C0E31767FBBD2F6">B.19-1 SetCoordinates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X790BE2F980902645">B.19-2 SetDefaultGraphCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X786FE7C97A76D747">B.19-3 SimpleGraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X858ADA3B7A684421">B.19-4 Size</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8723A75E7C614604">B.19-5 SnubDisphenoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7A142732800BA3FB">B.19-6 SpanningForest</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F041A81846012EE">B.19-7 SpanningForestEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X85D92DDF7EC14AF0">B.19-8 SpikyGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7DB6D22E86A5B572">B.19-9 SunGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8743540878E206BD">B.19-10 Suspension</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X809A4787809A4787">B.20 <span class="Heading">T</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7F7026FF83934BBC">B.20-1 TargetGraphCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B44DDD485145773">B.20-2 Tetrahedron</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X86C7A3E27AF64042">B.20-3 TimeInSeconds</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X803A2BC67C63AA25">B.20-4 TimesProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X87B9CA2A8552F40A">B.20-5 TorusGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C7EAB207C957EB1">B.20-6 TreeGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X82C1EADA7E3EE838">B.20-7 TrivialGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X87EA348E87EA348E">B.21 <span class="Heading">U</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X795BE08A79C126FC">B.21-1 UFFind</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8105AD137ECF5AE4">B.21-2 UFUnite</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7CC6D5C77C0CCFA3">B.21-3 UndirectedGraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7FDA5DD47D181699">B.21-4 UnitsRingGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X7E7AA1957E7AA195">B.22 <span class="Heading">V</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7B5898D98493A41D">B.22-1 VertexDegree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8406A82E7973EC00">B.22-2 VertexDegrees</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X86050933823255F1">B.22-3 VertexNames</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X79E4BB4F849AC8A1">B.22-4 Vertices</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X790AD29C790AD29C">B.23 <span class="Heading">W</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X817EA60D828A765E">B.23-1 WheelGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapB.html#X8771504C8771504C">B.24 <span class="Heading">Y</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8150D2E37EA1F25D">B.24-1 YAGSExec</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X865EB51A79C27268">B.24-2 YAGSInfo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X8602312E8239A2C0">B.24-3 YAGSInfo.InfoClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X837885A8851D670D">B.24-4 YAGSInfo.InfoOutput</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapB.html#X7C665D6881B1291F">B.24-5 YAGSPositionsTrueBlist</a></span>
</div></div>
</div>

<h3>B <span class="Heading"><strong class="pkg">YAGS</strong> Functions Reference</span></h3>

<p>This chapter contains a list of most <strong class="pkg">YAGS</strong>'s functions, with full definitions, in alphabetical order; but the predefined types of morphisms are best described in their own Section <a href="chap5.html#X7C6AE3D882EEFFFF"><span class="RefLink">5.2</span></a>.</p>

<p><a id="X864799C9864799C9" name="X864799C9864799C9"></a></p>

<h4>B.1 <span class="Heading">A</span></h4>

<p><a id="X8332EA8C8406B570" name="X8332EA8C8406B570"></a></p>

<h5>B.1-1 AddEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddEdges</code>( <var class="Arg">G</var>, <var class="Arg">E</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a new graph created from graph <var class="Arg">G</var> by adding the edges in list <var class="Arg">E</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);   </span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddEdges(g,[[1,3]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
5, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddEdges(g,[[1,3],[2,4]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
</pre></div>

<p><a id="X7CF12BD58616E814" name="X7CF12BD58616E814"></a></p>

<h5>B.1-2 AddVerticesByAdjacencies</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddVerticesByAdjacencies</code>( <var class="Arg">G</var>, <var class="Arg">NewAdjList</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a new graph created from graph <var class="Arg">G</var> by adding as many new vertices as <code class="code">Length(<var class="Arg">NewAdjList</var>)</code>. Each entry in <var class="Arg">NewAdjList</var> is also a list: the list of neighbors of the corresponding new vertex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddVerticesByAdjacencies(g,[[1,2],[4,5]]); </span>
Graph( rec( Category := SimpleGraphs, Order := 7, Size := 
8, Adjacencies := [ [ 2, 6 ], [ 1, 3, 6 ], [ 2, 4 ], [ 3, 5, 7 ], 
  [ 4, 7 ], [ 1, 2 ], [ 4, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddVerticesByAdjacencies(g,[[1,2,7],[4,5]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 7, Size := 
9, Adjacencies := [ [ 2, 6 ], [ 1, 3, 6 ], [ 2, 4 ], [ 3, 5, 7 ], 
  [ 4, 7 ], [ 1, 2, 7 ], [ 4, 5, 6 ] ] ) )
</pre></div>

<p><a id="X85A84B247E3DE0C6" name="X85A84B247E3DE0C6"></a></p>

<h5>B.1-3 Adjacencies</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Adjacencies</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the adjacency lists of graph <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Adjacencies(g);  </span>
[ [ 2 ], [ 1, 3 ], [ 2 ] ]
</pre></div>

<p><a id="X7CEFD50D868B8EEB" name="X7CEFD50D868B8EEB"></a></p>

<h5>B.1-4 Adjacency</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Adjacency</code>( <var class="Arg">G</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the adjacency list of vertex <var class="Arg">x</var> in <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Adjacency(g,1);           </span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Adjacency(g,2);</span>
[ 1, 3 ]
</pre></div>

<p><a id="X7B38E7137B6E12D6" name="X7B38E7137B6E12D6"></a></p>

<h5>B.1-5 AdjMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjMatrix</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the adjacency matrix of the graph <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjMatrix(CycleGraph(4));</span>
[ [ false, true, false, true ], [ true, false, true, false ], 
  [ false, true, false, true ], [ true, false, true, false ] ]
</pre></div>

<p><a id="X83C068317E95A402" name="X83C068317E95A402"></a></p>

<h5>B.1-6 AGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A 4-cycle with two pendant vertices on consecutive vertices of the cycle.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
6, Adjacencies := [ [ 2 ], [ 1, 3, 5 ], [ 2, 4 ], [ 3, 5 ], 
  [ 2, 4, 6 ], [ 5 ] ] ) )
</pre></div>

<p><a id="X81B477F881CB7FD6" name="X81B477F881CB7FD6"></a></p>

<h5>B.1-7 AntennaGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AntennaGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A <code class="code">HouseGraph</code> with a pendant vertex (antenna) on the roof.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AntennaGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
7, Adjacencies := [ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], 
  [ 1, 4, 6 ], [ 5 ] ] ) )
</pre></div>

<p><a id="X87677B0787B4461A" name="X87677B0787B4461A"></a></p>

<h5>B.1-8 AutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutGroupGraph</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the group of automorphisms of the graph <var class="Arg">G</var>. Both forms are synonyms.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutomorphismGroup(Icosahedron);</span>
Group([ (1,2,10,11,4)(5,6,9,12,7), (1,2,10,12,7,5)(3,9,11,8,4,6) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutGroupGraph(Icosahedron);</span>
Group([ (1,2,10,11,4)(5,6,9,12,7), (1,2,10,12,7,5)(3,9,11,8,4,6) ])
</pre></div>

<p><a id="X7FD70CD27FD70CD2" name="X7FD70CD27FD70CD2"></a></p>

<h4>B.2 <span class="Heading">B</span></h4>

<p><a id="X86C78160854C7F30" name="X86C78160854C7F30"></a></p>

<h5>B.2-1 Backtrack</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Backtrack</code>( <var class="Arg">L</var>, <var class="Arg">Opts</var>, <var class="Arg">Chk</var>, <var class="Arg">Done</var>, <var class="Arg">Extra</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Generic, user-customizable backtracking algorithm.</p>

<p>The non-expert programmer is advised to read Chapter <a href="chap6.html#X82DE80EC7BC3EF58"><span class="RefLink">6</span></a> first.</p>

<p>A backtracking algorithm explores a decision tree in search for solutions to a combinatorial problem. The combinatorial problem and the search strategy are specified by the parameters:</p>

<p><var class="Arg">L</var> is just a list that <code class="code">Backtrack</code> uses to keep track of solutions and partial solutions. It is usually set to the empty list as a starting point. After a solution is found, it is returned <em>and</em> stored in <var class="Arg">L</var>. This value of <var class="Arg">L</var> is then used as a starting point to search for the next solution in case <code class="code">Backtrack</code> is called again. Partial solutions are also stored in <var class="Arg">L</var> during the execution of <code class="code">Backtrack</code>.</p>

<p><var class="Arg">Extra</var> may be any object, list, record, etc. <code class="code">Backtrack</code> only uses it to pass this data to the user-defined functions <var class="Arg">Opts</var>, <var class="Arg">Chk</var> and <var class="Arg">Done</var>, therefore offering you a way to share data between your functions.</p>

<p><var class="Arg">Opts</var><code class="code">:=function(L,extra)</code> must return the list of continuation options (children) one has after some partial solution (node) <var class="Arg">L</var> has been reached within the decision tree (<var class="Arg">Opts</var> may use the extra data <var class="Arg">Extra</var> as needed). Each of the values in the list returned by <var class="Arg">Opts</var><code class="code">(L,extra)</code> will be tried as possible continuations of the partial solution <var class="Arg">L</var>. If <var class="Arg">Opts</var><code class="code">(L,extra)</code> always returns the same list, you can put that list in place of the parameter <var class="Arg">Opts</var>.</p>

<p><var class="Arg">Chk</var><code class="code">:=function(L,extra)</code> must evaluate the partial solution <var class="Arg">L</var> possibly using the extra data <var class="Arg">Extra</var> and must return <code class="code">false</code> when it knows that <var class="Arg">L</var> can not be extended to a solution of the problem. Otherwise it returns <code class="code">true</code>. <var class="Arg">Chk</var> may assume that <var class="Arg">L</var><code class="code">{[1..Length(L)-1]}</code> already passed the test.</p>

<p><var class="Arg">Done</var><code class="code">:=function(L,extra)</code> returns <code class="code">true</code> if <var class="Arg">L</var> is already a complete solution and <code class="code">false</code> otherwise. In many combinatorial problems, any partial solution of certain length <var class="Arg">n</var> is also a solution (and vice versa), so if this is your case, you can put that length in place of the parameter <var class="Arg">Done</var>.</p>

<p>The following example uses <code class="code">Backtrack</code> in its simplest form to compute derangements (permutations of a set, where none of the elements appears in its original position).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N:=4;;L:=[];;extra:=[];;opts:=[1..N];;done:=N;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chk:=function(L,extra) local i; i:=Length(L); </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          return not L[i] in L{[1..i-1]} and L[i]&lt;&gt; i; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 2, 1, 4, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 2, 3, 4, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 2, 4, 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 3, 1, 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 3, 4, 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 3, 4, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 4, 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 4, 3, 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
[ 4, 3, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Backtrack(L,opts,chk,done,extra);</span>
fail
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 3 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a> and Section <a href="chap6.html#X7F9CE7A87E7B0111"><span class="RefLink">6.4</span></a>).</p>

<p>Extensive information on <code class="code">Backtrack</code> and <code class="code">BacktrackBag</code> can be found in Chapter <a href="chap6.html#X82DE80EC7BC3EF58"><span class="RefLink">6</span></a>.</p>

<p><a id="X7A625FDE7D726FAB" name="X7A625FDE7D726FAB"></a></p>

<h5>B.2-2 BacktrackBag</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BacktrackBag</code>( <var class="Arg">Opts</var>, <var class="Arg">Chk</var>, <var class="Arg">Done</var>, <var class="Arg">Extra</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of all solutions that would be returned one at a time by <code class="code">Backtrack</code>.</p>

<p>The following example computes all derangements of order 4.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N:=4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chk:=function(L,extra) local i; i:=Length(L); </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          return not L[i] in L{[1..i-1]} and L[i]&lt;&gt; i; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BacktrackBag([1..N],chk,N,[]);</span>
[ [ 2, 1, 4, 3 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 3, 1, 4, 2 ], 
  [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 3, 1, 2 ], 
  [ 4, 3, 2, 1 ] ]
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 3 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a> and Section <a href="chap6.html#X7F9CE7A87E7B0111"><span class="RefLink">6.4</span></a>).</p>

<p>Extensive information on <code class="code">Backtrack</code> and <code class="code">BacktrackBag</code> can be found in Chapter <a href="chap6.html#X82DE80EC7BC3EF58"><span class="RefLink">6</span></a>.</p>

<p><a id="X7F2566527F566D99" name="X7F2566527F566D99"></a></p>

<h5>B.2-3 Basement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Basement</code>( <var class="Arg">G</var>, <var class="Arg">KnG</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Basement</code>( <var class="Arg">G</var>, <var class="Arg">KnG</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given a graph <var class="Arg">G</var>, some iterated clique graph <var class="Arg">KnG</var> of <var class="Arg">G</var> and a vertex <var class="Arg">x</var> of <var class="Arg">KnG</var>, the operation returns the <var class="Arg">basement</var> of <var class="Arg">x</var> with respect to <var class="Arg">G</var> <a href="chapBib.html#biBPiz04">[23]</a>. Loosely speaking, the basement of <var class="Arg">x</var> is the set of vertices of <var class="Arg">G</var> that constitutes the iterated clique <var class="Arg">x</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Icosahedron;;Cliques(g);</span>
[ [ 1, 2, 3 ], [ 1, 2, 6 ], [ 1, 3, 4 ], [ 1, 4, 5 ], [ 1, 5, 6 ], 
  [ 4, 5, 7 ], [ 4, 7, 11 ], [ 5, 7, 8 ], [ 7, 8, 12 ], 
  [ 7, 11, 12 ], [ 5, 6, 8 ], [ 6, 8, 9 ], [ 8, 9, 12 ], [ 2, 6, 9 ], 
  [ 2, 9, 10 ], [ 9, 10, 12 ], [ 2, 3, 10 ], [ 3, 10, 11 ], 
  [ 10, 11, 12 ], [ 3, 4, 11 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kg:=CliqueGraph(g);; k2g:=CliqueGraph(kg);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basement(g,k2g,1);Basement(g,k2g,2);</span>
[ 1, 2, 3, 4, 5, 6 ]
[ 1, 2, 3, 4, 6, 10 ]
</pre></div>

<p>Formally, taking <code class="code">m=n-1</code>, the basement is defined as follows:</p>

<div class="pcenter"><table class="GAPDocTablenoborder">
<tr>
<td class="tdleft"><code class="code">Basement(G,G,x):=x;</code></td>
</tr>
<tr>
<td class="tdleft"><code class="code">Basement(G,KG,x):=VertexNames(KG)[x];</code></td>
</tr>
<tr>
<td class="tdleft"><code class="code">Basement(G,KnG,x):= Union(List(VertexNames(KnG)[x]), z-&gt;Basement(G,KmG,z));</code></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>In its second form, <var class="Arg">V</var> is a set of vertices of <var class="Arg">KnG</var>, in that case, the basement is simply the union of the basements of the vertices in <var class="Arg">V</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basement(g,k2g,[1,2]);              </span>
[ 1, 2, 3, 4, 5, 6, 10 ]
</pre></div>

<p>Basements have been used to study distances and diameters of clique graphs in <a href="chapBib.html#biBBS95">[3]</a> and <a href="chapBib.html#biBPiz04">[23]</a>.</p>

<p><a id="X8643BBC5802677DE" name="X8643BBC5802677DE"></a></p>

<h5>B.2-4 BoundaryVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BoundaryVertices</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>When <var class="Arg">G</var> is (an underlying graph of a Whitney triangulation of) a compact surface, it returns the list of vertices in the boundary (of the triangulation) of the surface. That is, the list of vertices of <var class="Arg">G</var> whose link is isomorphic to a path of length at least 2. It returns <code class="code">fail</code> if <var class="Arg">G</var> is not a compact surface.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundaryVertices(WheelGraph(4,2));</span>
[ 6, 7, 8, 9 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundaryVertices(Octahedron);     </span>
[  ]
</pre></div>

<p><a id="X8724BE6381EA1A23" name="X8724BE6381EA1A23"></a></p>

<h5>B.2-5 BoxProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BoxProduct</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the box product, <var class="Arg">G</var><span class="SimpleMath">□</span><var class="Arg">H</var>, of two graphs <var class="Arg">G</var> and <var class="Arg">H</var> (also known as the Cartesian product).</p>

<p>The box product is calculated as follows:</p>

<p>For each pair of vertices <span class="SimpleMath">x ∈ <var class="Arg">G</var>, y ∈ <var class="Arg">H</var></span> we create a vertex <span class="SimpleMath">(x,y)</span>. Given two such vertices <span class="SimpleMath">(x,y)</span> and <span class="SimpleMath">(x',y')</span> they are adjacent iff <span class="SimpleMath">x = x</span> and <span class="SimpleMath">y ∼ y'</span> or <span class="SimpleMath">x ∼ x'</span> and <span class="SimpleMath">y = y'</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(3);h:=CycleGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gh:=BoxProduct(g,h);           </span>
Graph( rec( Category := SimpleGraphs, Order := 12, Size := 
20, Adjacencies := [ [ 2, 4, 5 ], [ 1, 3, 6 ], [ 2, 4, 7 ], 
  [ 1, 3, 8 ], [ 1, 6, 8, 9 ], [ 2, 5, 7, 10 ], [ 3, 6, 8, 11 ], 
  [ 4, 5, 7, 12 ], [ 5, 10, 12 ], [ 6, 9, 11 ], [ 7, 10, 12 ], 
  [ 8, 9, 11 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexNames(gh);</span>
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], 
  [ 2, 3 ], [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
</pre></div>

<p><a id="X7B338162824A09E3" name="X7B338162824A09E3"></a></p>

<h5>B.2-6 BoxTimesProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BoxTimesProduct</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the boxtimes product, <var class="Arg">G</var> <span class="SimpleMath">⊠</span> <var class="Arg">H</var>, of two graphs <var class="Arg">G</var> and <var class="Arg">H</var> (also known as the strong product).</p>

<p>The boxtimes product is calculated as follows:</p>

<p>For each pair of vertices <span class="SimpleMath">x ∈ <var class="Arg">G</var>, y ∈ <var class="Arg">H</var></span> we create a vertex <span class="SimpleMath">(x,y)</span>. Given two such vertices <span class="SimpleMath">(x,y)</span> and <span class="SimpleMath">(x',y')</span> such that <span class="SimpleMath">(x,y) ≠ (x',y')</span> they are adjacent iff <span class="SimpleMath">x ≃ x'</span> and <span class="SimpleMath">y ≃ y'</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(3);h:=CycleGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gh:=BoxTimesProduct(g,h);      </span>
Graph( rec( Category := SimpleGraphs, Order := 12, Size := 
36, Adjacencies := [ [ 2, 4, 5, 6, 8 ], [ 1, 3, 5, 6, 7 ], 
  [ 2, 4, 6, 7, 8 ], [ 1, 3, 5, 7, 8 ], [ 1, 2, 4, 6, 8, 9, 10, 12 ], 
  [ 1, 2, 3, 5, 7, 9, 10, 11 ], [ 2, 3, 4, 6, 8, 10, 11, 12 ], 
  [ 1, 3, 4, 5, 7, 9, 11, 12 ], [ 5, 6, 8, 10, 12 ], 
  [ 5, 6, 7, 9, 11 ], [ 6, 7, 8, 10, 12 ], [ 5, 7, 8, 9, 11 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexNames(gh);                 </span>
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], 
  [ 2, 3 ], [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
</pre></div>

<p><a id="X7A06294F8001BBC8" name="X7A06294F8001BBC8"></a></p>

<h5>B.2-7 BullGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BullGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A triangle with two pendant vertices (horns).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BullGraph;    </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 2 ], [ 1, 3, 4 ], [ 2, 4 ], [ 2, 3, 5 ], [ 4 ] 
 ] ) )
</pre></div>

<p><a id="X78A77FDB78A77FDB" name="X78A77FDB78A77FDB"></a></p>

<h4>B.3 <span class="Heading">C</span></h4>

<p><a id="X7AB3B70B7B5F8B4E" name="X7AB3B70B7B5F8B4E"></a></p>

<h5>B.3-1 CayleyGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CayleyGraph</code>( <var class="Arg">Grp</var>, <var class="Arg">Elms</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CayleyGraph</code>( <var class="Arg">Grp</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the graph <span class="SimpleMath">G</span> whose vertices are the elements of the group <var class="Arg">Grp</var> such that <span class="SimpleMath">x</span> is adjacent to <span class="SimpleMath">y</span> iff <span class="SimpleMath">x*g=y</span> for some <span class="SimpleMath">g</span> in the list <var class="Arg">Elms</var>. If <var class="Arg">Elms</var> is not provided, then the generators of <var class="Arg">G</var> are used instead.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">grp:=Group((1,2,3),(1,2));    </span>
Group([ (1,2,3), (1,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CayleyGraph(grp);             </span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
9, Adjacencies := [ [ 3, 4, 5 ], [ 3, 5, 6 ], [ 1, 2, 6 ], 
  [ 1, 5, 6 ], [ 1, 2, 4 ], [ 2, 3, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CayleyGraph(grp,[(1,2),(2,3)]);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
6, Adjacencies := [ [ 2, 3 ], [ 1, 5 ], [ 1, 4 ], [ 3, 6 ], [ 2, 6 ], 
  [ 4, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexNames(last);</span>
[ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ]
</pre></div>

<p><a id="X843994627A0728F1" name="X843994627A0728F1"></a></p>

<h5>B.3-2 ChairGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ChairGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The tree with degree sequence 3,2,1,1,1.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChairGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 2 ], [ 1, 3, 4 ], [ 2 ], [ 2, 5 ], [ 4 ] ] ) )
</pre></div>

<p><a id="X8301C7647DF897A1" name="X8301C7647DF897A1"></a></p>

<h5>B.3-3 Circulant</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Circulant</code>( <var class="Arg">n</var>, <var class="Arg">Jumps</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the graph <code class="code">G</code> whose vertices are <code class="code">[1..n]</code> such that <code class="code">x</code> is adjacent to <code class="code">y</code> iff <code class="code">x+z=y</code> mod <code class="code">n</code> for some <code class="code">z</code> in the list <var class="Arg">Jumps</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Circulant(6,[1,2]);   </span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 2, 3, 5, 6 ], [ 1, 3, 4, 6 ], [ 1, 2, 4, 5 ], 
  [ 2, 3, 5, 6 ], [ 1, 3, 4, 6 ], [ 1, 2, 4, 5 ] ] ) )
</pre></div>

<p><a id="X7DC2B392863DC66C" name="X7DC2B392863DC66C"></a></p>

<h5>B.3-4 ClawGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClawGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The graph on 4 vertices, 3 edges, and maximum degree 3.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClawGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1 ] ] ) )
</pre></div>

<p><a id="X80671C3A7AAF7B3F" name="X80671C3A7AAF7B3F"></a></p>

<h5>B.3-5 CliqueGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CliqueGraph</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CliqueGraph</code>( <var class="Arg">G</var>, <var class="Arg">maxNumCli</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the intersection graph, <span class="SimpleMath">K(<var class="Arg">G</var>)</span>, of all the (maximal) cliques of <var class="Arg">G</var>.</p>

<p>The additional parameter <var class="Arg">maxNumCli</var> aborts the computation when <var class="Arg">maxNumCli</var> cliques are found, even if they are all the cliques of <var class="Arg">G</var>. If the bound <var class="Arg">maxNumCli</var> is reached, <code class="code">fail</code> is returned. However, the clique graph of <var class="Arg">G</var> is returned if it has been computed earlier, regardless of the value of <var class="Arg">maxNumCli</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CliqueGraph(Cube);           </span>
Graph( rec( Category := SimpleGraphs, Order := 12, Size := 
24, Adjacencies := [ [ 2, 3, 5, 7 ], [ 1, 3, 4, 11 ], [ 1, 2, 8, 10 ],
  [ 2, 5, 6, 11 ], [ 1, 4, 6, 7 ], [ 4, 5, 9, 12 ], [ 1, 5, 8, 9 ], 
  [ 3, 7, 9, 10 ], [ 6, 7, 8, 12 ], [ 3, 8, 11, 12 ], 
  [ 2, 4, 10, 12 ], [ 6, 9, 10, 11 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CliqueGraph(Octahedron,8);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CliqueGraph(Octahedron,9); </span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
24, Adjacencies := [ [ 2, 3, 4, 5, 6, 7 ], [ 1, 3, 4, 5, 6, 8 ], 
  [ 1, 2, 4, 5, 7, 8 ], [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 3, 6, 7, 8 ], 
  [ 1, 2, 4, 5, 7, 8 ], [ 1, 3, 4, 5, 6, 8 ], [ 2, 3, 4, 5, 6, 7 ] 
 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CliqueGraph(Octahedron,8); </span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
24, Adjacencies := [ [ 2, 3, 4, 5, 6, 7 ], [ 1, 3, 4, 5, 6, 8 ], 
  [ 1, 2, 4, 5, 7, 8 ], [ 1, 2, 3, 6, 7, 8 ], [ 1, 2, 3, 6, 7, 8 ], 
  [ 1, 2, 4, 5, 7, 8 ], [ 1, 3, 4, 5, 6, 8 ], [ 2, 3, 4, 5, 6, 7 ] 
 ] ) )
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 1 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a>).</p>

<p><a id="X78427A8B81FEB457" name="X78427A8B81FEB457"></a></p>

<h5>B.3-6 CliqueNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CliqueNumber</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the order, <span class="SimpleMath">ω( <var class="Arg">G</var> )</span>, of a maximum clique of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=SunGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
14, Adjacencies := [ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], 
  [ 2, 3, 5, 6, 8 ], [ 4, 6 ], [ 2, 4, 5, 7, 8 ], [ 6, 8 ], 
  [ 1, 2, 4, 6, 7 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cliques(g);</span>
[ [ 2, 4, 6, 8 ], [ 2, 3, 4 ], [ 1, 2, 8 ], [ 4, 5, 6 ], [ 6, 7, 8 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CliqueNumber(g);</span>
4
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 1 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a>).</p>

<p><a id="X7AA94AAB7961CEC0" name="X7AA94AAB7961CEC0"></a></p>

<h5>B.3-7 Cliques</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cliques</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cliques</code>( <var class="Arg">G</var>, <var class="Arg">maxNumCli</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the set of all (maximal) cliques of a graph <var class="Arg">G</var>. A clique is a maximal complete subgraph. Here, we use the Bron-Kerbosch algorithm <a href="chapBib.html#biBBK73">[4]</a>.</p>

<p>In the second form, It stops computing cliques after <var class="Arg">maxNumCli</var> of them have been found.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cliques(Octahedron);  </span>
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
  [ 2, 3, 6 ], [ 2, 4, 5 ], [ 2, 4, 6 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cliques(Octahedron,4);</span>
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ] ]
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 1 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a>).</p>

<p><a id="X80444D068708D026" name="X80444D068708D026"></a></p>

<h5>B.3-8 ClockworkGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClockworkGraph</code>( <var class="Arg">NNFSList</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClockworkGraph</code>( <var class="Arg">NNFSList</var>, <var class="Arg">rank</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClockworkGraph</code>( <var class="Arg">NNFSList</var>, <var class="Arg">Perm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClockworkGraph</code>( <var class="Arg">NNFSList</var>, <var class="Arg">rank</var>, <var class="Arg">Perm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the clockwork graph <a href="chapBib.html#biBLN02">[13]</a><a href="chapBib.html#biBLNP04">[15]</a> specified by its parameters.</p>

<p>Clockwork graphs have been very useful in constructing examples and counter-examples in clique graph theory. In particular, they have been used to construct examples of clique-periodic graphs of all possible periods <a href="chapBib.html#biBEsc73">[6]</a>, clique-divergent graphs of linear and polynomial growth rate <a href="chapBib.html#biBLN97">[16]</a><a href="chapBib.html#biBLN02">[13]</a>, clique-convergent graphs whose period is not invariant under removal of dominated vertices <a href="chapBib.html#biBFNP04">[8]</a>, clique-convergent graphs which become clique-divergent by just gluing a 4-cycle to a vertex <a href="chapBib.html#biBFLNP13">[7]</a>, rank-divergent graphs <a href="chapBib.html#biBLNP06">[17]</a>, etc.</p>

<p>A clockwork graph consists of two parts: the crown and the core, both of them are <em>cyclically segmented</em>. When not specified, the <var class="Arg">rank</var> is assumed to be 2 and the <em>return permutation</em>, <var class="Arg">Perm</var>, is assumed to be trivial, let us assume this is our case. Consider the following examples:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClockworkGraph([[0],[0],[0],[0]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 12, Size := 
28, Adjacencies := [ [ 2, 3, 4, 10, 12 ], [ 1, 3, 5, 11, 12 ], 
  [ 1, 2, 4, 5 ], [ 1, 3, 5, 6, 7 ], [ 2, 3, 4, 6, 8 ], 
  [ 4, 5, 7, 8 ], [ 4, 6, 8, 9, 10 ], [ 5, 6, 7, 9, 11 ], 
  [ 7, 8, 10, 11 ], [ 1, 7, 9, 11, 12 ], [ 2, 8, 9, 10, 12 ], 
  [ 1, 2, 10, 11 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClockworkGraph([[1],[1],[1],[1]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 12, Size := 
32, Adjacencies := [ [ 2, 3, 4, 10, 12 ], [ 1, 3, 5, 11, 12 ], 
  [ 1, 2, 4, 5, 6, 12 ], [ 1, 3, 5, 6, 7 ], [ 2, 3, 4, 6, 8 ], 
  [ 3, 4, 5, 7, 8, 9 ], [ 4, 6, 8, 9, 10 ], [ 5, 6, 7, 9, 11 ], 
  [ 6, 7, 8, 10, 11, 12 ], [ 1, 7, 9, 11, 12 ], [ 2, 8, 9, 10, 12 ], 
  [ 1, 2, 3, 9, 10, 11 ] ] ) )
</pre></div>

<p>In both cases, the crown is the subgraph induced by the vertices <span class="SimpleMath">{1,2,4,5,7,8,10,11}</span> and the core is induced by <span class="SimpleMath">{3,6,9,12}</span>. Also in both cases the cyclic segmentations (partitions) of the crown and the core are <span class="SimpleMath">{{1,2},{4,5},{7,8},{10,11}}</span> and <span class="SimpleMath">{{3},{6},{9},{12}}</span> respectively. The number of segments <var class="Arg">s</var> is specified by <code class="code"><var class="Arg">s</var>:=Length(<var class="Arg">NNFSList</var>)</code> which is 4 in these cases. The crown is isomorphic to <code class="code">BoxProduct(CycleGraph(<var class="Arg">s</var>),Completegraph(<var class="Arg">rank</var>))</code>: All the crown segments are complete subgraphs and the vertices of cyclically consecutive segments are joined by a perfect matching. The adjacencies between crown and core vertices are simple to describe: Cyclically intercalate crown and core segments, making each core vertex adjacent to the vertices in the previous and the following crown segments. Hence in our examples vertex 3 is adjacent to vertices 1 and 2 (previous segment), but also 4 and 5 (following segment). Note that since the segmentations and intercalations are <var class="Arg">cyclic</var>, we have that vertex 12 is adjacent to 10 and 11, but also to 1 and 2. Finally the edges between core vertices are as follows: first each core segment is a complete subgraph; the vertices within each core segment are linearly ordered and for vertex number <var class="Arg">t</var> in segment number <var class="Arg">s</var> there is a non-negative integer <code class="code"><var class="Arg">NNFSList</var>[s][t]</code> which specifies, the <var class="Arg">Number of Neighbors in the Following core Segment</var> for that vertex (hence the name <var class="Arg">NNFSList</var>) (Since the vertices in core segments are linearly ordered, it is enough to specify the <var class="Arg">number</var> of neighbors in the following segment and the <var class="Arg">first</var> ones of those are selected as the neighbors). Hence in our two examples above, each core segment consists of exactly one vertex. In the first example each core segment is adjacent to no vertex in the following segment (e.g. 3 is not adjacent to 6) but in the second one, each core segment is adjacent to exactly one vertex in the following segment (e.g. 3 is adjacent to 6).</p>

<p>A more complicated example should be now mostly self-explanatory:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClockworkGraph([[2],[0,1,3],[0,1,1],[1]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 16, Size := 
59, Adjacencies := [ [ 2, 3, 4, 14, 16 ], [ 1, 3, 5, 15, 16 ], 
  [ 1, 2, 4, 5, 6, 7, 16 ], [ 1, 3, 5, 6, 7, 8, 9 ], 
  [ 2, 3, 4, 6, 7, 8, 10 ], [ 3, 4, 5, 7, 8, 9, 10 ], 
  [ 3, 4, 5, 6, 8, 9, 10, 11 ], [ 4, 5, 6, 7, 9, 10, 11, 12, 13 ], 
  [ 4, 6, 7, 8, 10, 11, 12, 13, 14 ], 
  [ 5, 6, 7, 8, 9, 11, 12, 13, 15 ], [ 7, 8, 9, 10, 12, 13, 14, 15 ], 
  [ 8, 9, 10, 11, 13, 14, 15, 16 ], [ 8, 9, 10, 11, 12, 14, 15, 16 ], 
  [ 1, 9, 11, 12, 13, 15, 16 ], [ 2, 10, 11, 12, 13, 14, 16 ], 
  [ 1, 2, 3, 12, 13, 14, 15 ] ] ) )
</pre></div>

<p>The crown and core segmentations are <span class="SimpleMath">{{1,2},{4,5},{9,10},{14,15}}</span> and <span class="SimpleMath">{{3},{6,7,8},{11,12,13},{16}}</span> respectively and the adjacencies specified by the <var class="Arg">NNFSList</var> are: 3 is adjacent to 6 and 7; 6 is adjacent to none (in the following core segment); 7 is adjacent to 11; 8 to 11, 12 and 13; 11 to none; 12 to 16; 13 to 16 and 16 to 3.</p>

<p>When <var class="Arg">rank</var> and/or <var class="Arg">Perm</var> are specified, they have the following effects: <var class="Arg">rank</var> (which must be at least 2) is the number of vertices in each crown segment, and <var class="Arg">Perm</var> (which must belong to SymmetricGroup( <var class="Arg">rank</var> )) specifies the perfect matching joining the vertices in the last crown segment with the vertices in the first crown segment: The <var class="Arg">k</var>-th vertex in the last crown segment <span class="SimpleMath">k∈ {1,2,...,rank}</span> is made adjacent to the <span class="SimpleMath">Perm(k)</span>-th vertex of the first crown segment.</p>

<p>A number of requisites are put forward in the literature for a graph to be a clockwork graph but this operation does not enforce those conditions, on the contrary, it tries to make sense of the data provided as much as possible. For instance <code class="code"><var class="Arg">NNFSList</var>:=[[2],[2],[2],[2]]</code> would be inconsistent since there are not enough vertices in each core segment to provide for the required 2 neighbors. However, the result is just the same as with <code class="code"><var class="Arg">NNFSList</var>:=[[1],[1],[1],[1]]</code>. The requisites that are mandatory are exactly these: the <var class="Arg">rank</var> must be at least 2, <var class="Arg">Perm</var> must belong to SymmetricGroup(<var class="Arg">rank</var>), <var class="Arg">NNFSList</var> must be a list of lists of non-negative integers, and the number of segments (= Length(<var class="Arg">NNFSList</var>)) must be at least 3. A call to ClockworkGraph which fails to conform to these requisites will produce an error.</p>

<p><a id="X8091AC40834A0801" name="X8091AC40834A0801"></a></p>

<h5>B.3-9 ComplementGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComplementGraph</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the new graph <var class="Arg">H</var> such that <span class="SimpleMath">V( <var class="Arg">H</var> )=V( <var class="Arg">G</var> )</span> and <span class="SimpleMath">xy∈ E( <var class="Arg">H</var> ) &lt;=&gt; xy not\in E( <var class="Arg">G</var> )</span>.</p>


<div class="example"><pre> 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=ClawGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ComplementGraph(g);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [  ], [ 3, 4 ], [ 2, 4 ], [ 2, 3 ] ] ) )
</pre></div>

<p><a id="X8350EBF38416F1F5" name="X8350EBF38416F1F5"></a></p>

<h5>B.3-10 CompleteBipartiteGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompleteBipartiteGraph</code>( <var class="Arg">n</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the complete bipartite whose parts have order <var class="Arg">n</var> and <var class="Arg">m</var> respectively. This is the joint (Zykov sum) of two discrete graphs of order <var class="Arg">n</var> and <var class="Arg">m</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompleteBipartiteGraph(2,3);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
6, Adjacencies := [ [ 3, 4, 5 ], [ 3, 4, 5 ], [ 1, 2 ], [ 1, 2 ], 
  [ 1, 2 ] ] ) )
</pre></div>

<p><a id="X7A18A66783A3EA09" name="X7A18A66783A3EA09"></a></p>

<h5>B.3-11 CompleteGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompleteGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the complete graph of order <var class="Arg">n</var>. A complete graph is a graph where all vertices are connected to each other.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompleteGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
</pre></div>

<p><a id="X7839FF457E264FE1" name="X7839FF457E264FE1"></a></p>

<h5>B.3-12 CompletelyParedGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompletelyParedGraph</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the completely pared graph of <var class="Arg">G</var>, which is obtained by repeatedly applying <code class="code">ParedGraph</code> until no more dominated vertices remain.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(6);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
5, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], 
  [ 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompletelyParedGraph(g);</span>
Graph( rec( Category := SimpleGraphs, Order := 1, Size := 
0, Adjacencies := [ [  ] ] ) )
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 1 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a>).</p>

<p><a id="X7B19862D7C5D5A92" name="X7B19862D7C5D5A92"></a></p>

<h5>B.3-13 CompleteMultipartiteGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompleteMultipartiteGraph</code>( <var class="Arg">n1</var>, <var class="Arg">n2</var>[, <var class="Arg">n3</var>, <var class="Arg">...</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the complete multipartite graph where the orders of the parts are <var class="Arg">n1</var>, <var class="Arg">n2</var>, ... It is also the Zykov sum of discrete graphs of order <var class="Arg">n1</var>, <var class="Arg">n2</var>, ...</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompleteMultipartiteGraph(2,2,2);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], 
  [ 1, 2, 5, 6 ], [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] ) )
</pre></div>

<p><a id="X7C0053187FFA2F57" name="X7C0053187FFA2F57"></a></p>

<h5>B.3-14 CompletesOfGivenOrder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompletesOfGivenOrder</code>( <var class="Arg">G</var>, <var class="Arg">ord</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of vertex sets of all complete subgraphs of order <var class="Arg">ord</var> of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=SunGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
14, Adjacencies := [ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], 
  [ 2, 3, 5, 6, 8 ], [ 4, 6 ], [ 2, 4, 5, 7, 8 ], [ 6, 8 ], 
  [ 1, 2, 4, 6, 7 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompletesOfGivenOrder(g,3);</span>
[ [ 1, 2, 8 ], [ 2, 3, 4 ], [ 2, 4, 6 ], [ 2, 4, 8 ], [ 2, 6, 8 ], 
  [ 4, 5, 6 ], [ 4, 6, 8 ], [ 6, 7, 8 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompletesOfGivenOrder(g,4);</span>
[ [ 2, 4, 6, 8 ] ]
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 3 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a> and Section <a href="chap6.html#X7F9CE7A87E7B0111"><span class="RefLink">6.4</span></a>).</p>

<p><a id="X7DA501097D22881C" name="X7DA501097D22881C"></a></p>

<h5>B.3-15 Composition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Composition</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the composition <span class="SimpleMath"><var class="Arg">G</var>[<var class="Arg">H</var>]</span> of two graphs <var class="Arg">G</var> and <var class="Arg">H</var>.</p>

<p>A composition of graphs is obtained by calculating the <code class="code">GraphSum</code> of <var class="Arg">G</var> with <code class="code">Order(<var class="Arg">G</var>)</code> copies of <var class="Arg">H</var>, <code class="code"><var class="Arg">G</var>[<var class="Arg">H</var>] = GraphSum(<var class="Arg">G</var>, [<var class="Arg">H</var>, ..., <var class="Arg">H</var>])</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;h:=DiscreteGraph(2);;                  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Composition(g,h);                      </span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
16, Adjacencies := [ [ 3, 4, 7, 8 ], [ 3, 4, 7, 8 ], [ 1, 2, 5, 6 ], 
  [ 1, 2, 5, 6 ], [ 3, 4, 7, 8 ], [ 3, 4, 7, 8 ], [ 1, 2, 5, 6 ], 
  [ 1, 2, 5, 6 ] ] ) )
</pre></div>

<p><a id="X822975FC7F646FE5" name="X822975FC7F646FE5"></a></p>

<h5>B.3-16 Cone</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cone</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the cone of graph <var class="Arg">G</var>. The cone of <var class="Arg">G</var> is the graph obtained from <var class="Arg">G</var> by adding a new vertex which is adjacent to every vertex of <var class="Arg">G</var>. The new vertex is the first one in the new graph.</p>


<div class="example"><pre> 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cone(CycleGraph(4));</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
8, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 5 ], [ 1, 2, 4 ], 
  [ 1, 3, 5 ], [ 1, 2, 4 ] ] ) )
</pre></div>

<p><a id="X7945A3B47D94FA49" name="X7945A3B47D94FA49"></a></p>

<h5>B.3-17 ConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConnectedComponents</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the <em>connected components</em> of <var class="Arg">G</var>.</p>

<p>Two vertices in a graph are <em>reachable</em> (from each other) if there is a path connecting them. Two vertices are in the same connected component iff they are reachable from each other. This operation thus computes the equivalence partition of the equivalence relation "reachable".</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=GraphByWalks([3,1,4],[5,2]);     </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
3, Adjacencies := [ [ 3, 4 ], [ 5 ], [ 1 ], [ 1 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConnectedComponents(g);             </span>
[ [ 1, 3, 4 ], [ 2, 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=Composition(DiscreteGraph(3),g);</span>
Graph( rec( Category := SimpleGraphs, Order := 15, Size := 
9, Adjacencies := [ [ 3, 4 ], [ 5 ], [ 1 ], [ 1 ], [ 2 ], [ 8, 9 ], 
  [ 10 ], [ 6 ], [ 6 ], [ 7 ], [ 13, 14 ], [ 15 ], [ 11 ], [ 11 ], 
  [ 12 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConnectedComponents(g1);            </span>
[ [ 1, 3, 4 ], [ 2, 5 ], [ 6, 8, 9 ], [ 7, 10 ], [ 11, 13, 14 ], 
  [ 12, 15 ] ]
</pre></div>

<p><a id="X7ACA1C6F7BB211C4" name="X7ACA1C6F7BB211C4"></a></p>

<h5>B.3-18 ConnectedGraphsOfGivenOrder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConnectedGraphsOfGivenOrder</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of all connected graphs of order <var class="Arg">n</var> (up to isomorphism). This operation uses Brendan McKay's data published here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html">https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html</a></span>.</p>

<p>The data are included with the <strong class="pkg">YAGS</strong> distribution in its <code class="code">data</code> directory. Hence this operation simply reads the corresponding file in that directory using <code class="code">ImportGraph6( <var class="Arg">Filename</var> )</code>. Therefore, the integer <var class="Arg">n</var> must be in the range from 1 up to 9.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConnectedGraphsOfGivenOrder(3);</span>
[ Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
    2, Adjacencies := [ [ 3 ], [ 3 ], [ 1, 2 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
    3, Adjacencies := [ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConnectedGraphsOfGivenOrder(4);</span>
[ Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    3, Adjacencies := [ [ 4 ], [ 4 ], [ 4 ], [ 1, 2, 3 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    3, Adjacencies := [ [ 3, 4 ], [ 4 ], [ 1 ], [ 1, 2 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    4, Adjacencies := [ [ 3, 4 ], [ 4 ], [ 1, 4 ], [ 1, 2, 3 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    4, Adjacencies := [ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    5, Adjacencies := [ [ 3, 4 ], [ 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] 
     ] ) ), Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
      [ 1, 2, 3 ] ] ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(ConnectedGraphsOfGivenOrder(9));</span>
261080
</pre></div>

<p>Data for graphs on 10 vertices is also available, but not included with <strong class="pkg">YAGS</strong>, it may not be practical to use that data, but if you would like to try, all you have to do is to copy (and to uncompress) the corresponding file into the directory <code class="file">YAGS-DIR/data/</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConnectedGraphsOfGivenOrder(10);       </span>
#W Unreadable File: /opt/gap-4.10.2/pkg/yags/data/graph10c.g6
fail
</pre></div>

<p><a id="X84E3985A8700B302" name="X84E3985A8700B302"></a></p>

<h5>B.3-19 Coordinates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Coordinates</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Gets the coordinates of the vertices of <var class="Arg">G</var>, which are used to draw <var class="Arg">G</var> by <code class="code">Draw( <var class="Arg">G</var> )</code>. If the coordinates have not been previously set, <code class="code">Coordinates</code> returns <var class="Arg">fail</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(g);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetCoordinates(g,[[-10,-10 ],[-10,20],[20,-10 ], [20,20]]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(g);</span>
[ [ -10, -10 ], [ -10, 20 ], [ 20, -10 ], [ 20, 20 ] ]
</pre></div>

<p><a id="X84873D6E809669D2" name="X84873D6E809669D2"></a></p>

<h5>B.3-20 CopyCoordinates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CopyCoordinates</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CopyCoordinates</code>( <var class="Arg">G</var>, <var class="Arg">H</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Sets the coordinates of <var class="Arg">G</var> to be a copy of those of <var class="Arg">H</var>. If the coordinates of <var class="Arg">H</var> have not been previously set, <code class="func">CopyCoordinates</code> silently does nothing. <var class="Arg">G</var> and <var class="Arg">H</var> must have the same number of vertices, otherwise, <var class="Arg">fail</var> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=CycleGraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetCoordinates(H,[[-10,-10 ],[-10,20],[20,-10 ], [20,20]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:=CompleteGraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(G);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CopyCoordinates(G,H);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(G);</span>
[ [ -10, -10 ], [ -10, 20 ], [ 20, -10 ], [ 20, 20 ] ]
</pre></div>

<p>In its second form, <var class="Arg">V</var> is a list specifying how the vertices of <var class="Arg">G</var> are obtained from <var class="Arg">H</var>. Often, <var class="Arg">V</var> can be the <code class="func">VertexNames</code> (<a href="chapB.html#X86050933823255F1"><span class="RefLink">B.22-3</span></a>) of <var class="Arg">G</var>. Formally, each element of <var class="Arg">V</var> specifies a vertex of <var class="Arg">G</var>, hence it is necessary that <code class="code">Length(<var class="Arg">V</var>)=Order(<var class="Arg">G</var>)</code>. Also, each element of <var class="Arg">V</var> is either a vertex of <var class="Arg">H</var> or a subset of vertices of <var class="Arg">H</var>. Then the coordinates of the vertex specified by an element <code class="code">s</code> of <var class="Arg">V</var> is simply the average of the coordinates of the vertices of <code class="code">s</code> in <var class="Arg">H</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=PathGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetCoordinates(H,[[0,0],[10,0],[20,0],[50,0],[110,0]]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:=PathGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CopyCoordinates(G,H,[[1,2],3,[],[3,4,5]]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(G);</span>
[ [ 5, 0 ], [ 20, 0 ], [ 0, 0 ], [ 60, 0 ] ]
</pre></div>

<p><code class="func">CopyCoordinates</code> is used internally by <strong class="pkg">YAGS</strong> in most of its standard constructions.</p>

<p><a id="X7A907C8C7B5CA8B7" name="X7A907C8C7B5CA8B7"></a></p>

<h5>B.3-21 CopyGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CopyGraph</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a fresh copy of the graph <var class="Arg">G</var>. Only the order and adjacency information is copied, all other known attributes of <var class="Arg">G</var> are not. Mainly used to transform a graph from one category to another. The new graph will be forced to comply with the <code class="code">TargetGraphCategory</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CompleteGraph(4);                         </span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=CopyGraph(g:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 3, 4 ], [ 4 ], [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CopyGraph(g1:GraphCategory:=SimpleGraphs);     </span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
</pre></div>

<p><a id="X79F9336684F71FDE" name="X79F9336684F71FDE"></a></p>

<h5>B.3-22 Cube</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cube</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The 1-skeleton of Plato's cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cube;</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
12, Adjacencies := [ [ 2, 3, 5 ], [ 1, 4, 6 ], [ 1, 4, 7 ], 
  [ 2, 3, 8 ], [ 1, 6, 7 ], [ 2, 5, 8 ], [ 3, 5, 8 ], [ 4, 6, 7 ] 
 ] ) )
</pre></div>

<p><a id="X7C029AA28008AEE9" name="X7C029AA28008AEE9"></a></p>

<h5>B.3-23 CubeGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CubeGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the hypercube of dimension <var class="Arg">n</var>. This is the box product (Cartesian product) of <var class="Arg">n</var> copies of <span class="SimpleMath">K_2</span> (an edge).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CubeGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
12, Adjacencies := [ [ 2, 3, 5 ], [ 1, 4, 6 ], [ 1, 4, 7 ], 
  [ 2, 3, 8 ], [ 1, 6, 7 ], [ 2, 5, 8 ], [ 3, 5, 8 ], [ 4, 6, 7 ] 
 ] ) )
</pre></div>

<p><a id="X7F6EC0AE81531C3C" name="X7F6EC0AE81531C3C"></a></p>

<h5>B.3-24 CycleGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CycleGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the cyclic graph on <var class="Arg">n</var> vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CycleGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] 
 ] ) )
</pre></div>

<p><a id="X865BCD6C80C3E48E" name="X865BCD6C80C3E48E"></a></p>

<h5>B.3-25 CylinderGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CylinderGraph</code>( <var class="Arg">b</var>, <var class="Arg">h</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a cylinder of base <var class="Arg">b</var> and height <var class="Arg">h</var>. The order of this graph is <var class="Arg">b</var>(<var class="Arg">h</var>+1) and it is constructed by taking <var class="Arg">h</var>+1 copies of the cyclic graph on <var class="Arg">b</var> vertices, ordering these cycles linearly and then joining consecutive cycles by a zigzagging (2<var class="Arg">b</var>)-cycle. This graph is a triangulation of the cylinder where all internal vertices are of degree 6 and the boundary vertices are of degree 4.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CylinderGraph(4,1);</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
16, Adjacencies := [ [ 2, 4, 5, 6 ], [ 1, 3, 6, 7 ], [ 2, 4, 7, 8 ], 
  [ 1, 3, 5, 8 ], [ 1, 4, 6, 8 ], [ 1, 2, 5, 7 ], [ 2, 3, 6, 8 ], 
  [ 3, 4, 5, 7 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CylinderGraph(4,2);</span>
Graph( rec( Category := SimpleGraphs, Order := 12, Size := 
28, Adjacencies := [ [ 2, 4, 5, 6 ], [ 1, 3, 6, 7 ], [ 2, 4, 7, 8 ], 
  [ 1, 3, 5, 8 ], [ 1, 4, 6, 8, 9, 10 ], [ 1, 2, 5, 7, 10, 11 ], 
  [ 2, 3, 6, 8, 11, 12 ], [ 3, 4, 5, 7, 9, 12 ], [ 5, 8, 10, 12 ], 
  [ 5, 6, 9, 11 ], [ 6, 7, 10, 12 ], [ 7, 8, 9, 11 ] ] ) )
</pre></div>

<p><a id="X8141368181413681" name="X8141368181413681"></a></p>

<h4>B.4 <span class="Heading">D</span></h4>

<p><a id="X7F3EDB5C844C33FE" name="X7F3EDB5C844C33FE"></a></p>

<h5>B.4-1 DartGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DartGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A diamond with a pendant vertex and maximum degree 4.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DartGraph; </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
6, Adjacencies := [ [ 2 ], [ 1, 3, 4, 5 ], [ 2, 4, 5 ], [ 2, 3 ], 
  [ 2, 3 ] ] ) )
</pre></div>

<p><a id="X783AC7917B34BEEB" name="X783AC7917B34BEEB"></a></p>

<h5>B.4-2 DeclareQtfyProperty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeclareQtfyProperty</code>( <var class="Arg">Name</var>, <var class="Arg">Filter</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For internal use.</p>

<p>Declares a <strong class="pkg">YAGS</strong> quantifiable property named <var class="Arg">Name</var> for filter <var class="Arg">Filter</var>. This in turns, declares a Boolean <strong class="pkg">GAP</strong> property <var class="Arg">Name</var> and an integer <strong class="pkg">GAP</strong> attribute <var class="Arg">QtfyName</var>.</p>

<p>The user must provide the method <var class="Arg">Name</var>(<var class="Arg">Obj</var>, <var class="Arg">qtfy</var>). If <var class="Arg">qtfy</var> is false, the method must return a Boolean indicating whether the property holds, otherwise, the method must return a non-negative integer quantifying how far is the object from satisfying the property. In the latter case, returning 0 actually means that the object does satisfy the property.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareQtfyProperty("Is2Regular",Graphs);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod(Is2Regular,"for graphs",true,[Graphs,IsBool],0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">function(G,qtfy)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local x,count;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  count:=0;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  for x in Vertices(G) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if VertexDegree(G,x)&lt;&gt; 2 then </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if not qtfy then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        count:=count+1;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  if not qtfy then return true; fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return count;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Is2Regular(CycleGraph(4));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QtfyIs2Regular(CycleGraph(4));</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Is2Regular(DiamondGraph);     </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QtfyIs2Regular(DiamondGraph);</span>
2
</pre></div>

<p><a id="X822BD6B9862D6325" name="X822BD6B9862D6325"></a></p>

<h5>B.4-3 DFSTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DFSTree</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DFSTree</code>( <var class="Arg">G</var>, <var class="Arg">root</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the depth first search (DFS) tree the undirected graph <var class="Arg">G</var>.</p>

<p>A DFS tree is a rooted oriented tree (arrows go from parents to children). The root is chosen to be vertex 1 unless other root is specified by means of the optional parameter <var class="Arg">root</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=SunGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
9, Adjacencies := [ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], [ 2, 3, 5, 6 ], 
  [ 4, 6 ], [ 1, 2, 4, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DFSTree(g);</span>
Graph( rec( Category := OrientedGraphs, Order := 6, Size := 
5, Adjacencies := [ [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DFSTree(g,2);</span>
Graph( rec( Category := OrientedGraphs, Order := 6, Size := 
5, Adjacencies := [ [ 6 ], [ 1 ], [  ], [ 3, 5 ], [  ], [ 4 ] ] ) )
</pre></div>

<p><a id="X7AB7F57C832586ED" name="X7AB7F57C832586ED"></a></p>

<h5>B.4-4 Diameter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Diameter</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the maximum among the distances between pairs of vertices of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] 
 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Diameter(g);</span>
2
</pre></div>

<p><a id="X84CE76487939DD04" name="X84CE76487939DD04"></a></p>

<h5>B.4-5 DiamondGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiamondGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The graph on 4 vertices and 5 edges.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiamondGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
5, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3 ], [ 1, 2, 4 ], [ 1, 3 ] ] ) )
</pre></div>

<p><a id="X867DF890879C4CD5" name="X867DF890879C4CD5"></a></p>

<h5>B.4-6 DiscreteGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiscreteGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the discrete graph of order <var class="Arg">n</var>. A discrete graph is a graph without edges.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiscreteGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
0, Adjacencies := [ [  ], [  ], [  ], [  ] ] ) )
</pre></div>

<p><a id="X7B00BD6C843CFA42" name="X7B00BD6C843CFA42"></a></p>

<h5>B.4-7 DisjointUnion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DisjointUnion</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the disjoint union of two graphs <var class="Arg">G</var> and <var class="Arg">H</var>, <span class="SimpleMath">G ∪ H</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(3);h:=PathGraph(2); </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisjointUnion(g,h);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
3, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ], [ 5 ], [ 4 ] ] ) )
</pre></div>

<p><a id="X7C3CB921842888BE" name="X7C3CB921842888BE"></a></p>

<h5>B.4-8 Distance</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Distance</code>( <var class="Arg">G</var>, <var class="Arg">x</var>, <var class="Arg">y</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the minimum length of a path connecting <var class="Arg">x</var> to <var class="Arg">y</var> in <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Distance(CycleGraph(5),1,3);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Distance(CycleGraph(5),1,5);</span>
1
</pre></div>

<p><a id="X7ADA443D7FBDD1A5" name="X7ADA443D7FBDD1A5"></a></p>

<h5>B.4-9 Distances</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Distances</code>( <var class="Arg">G</var>, <var class="Arg">A</var>, <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given two lists of vertices <var class="Arg">A</var>, <var class="Arg">B</var> of a graph <var class="Arg">G</var>, <code class="code">Distances</code> returns the list of distances for every pair in the Cartesian product of <var class="Arg">A</var> and <var class="Arg">B</var>. The order of the vertices in lists <var class="Arg">A</var> and <var class="Arg">B</var> affects the order of the list of distances returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Distances(g, [1,3], [2,4]);</span>
[ 1, 2, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Distances(g, [3,1], [2,4]);</span>
[ 1, 1, 1, 2 ]
</pre></div>

<p><a id="X7C8F3D3385BF41DA" name="X7C8F3D3385BF41DA"></a></p>

<h5>B.4-10 DistanceGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DistanceGraph</code>( <var class="Arg">G</var>, <var class="Arg">Dist</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given a graph <var class="Arg">G</var> and a list of distances <var class="Arg">Dist</var>, <code class="code">DistanceGraph</code> returns the new graph constructed on the vertices of <var class="Arg">G</var> where two vertices are adjacent iff the distance (in <var class="Arg">G</var>) between them belongs to the list <var class="Arg">Dist</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(5);            </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] 
 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DistanceGraph(g,[2]);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 3, 4 ], [ 4, 5 ], [ 1, 5 ], [ 1, 2 ], [ 2, 3 ] 
 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DistanceGraph(g,[1,2]);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
10, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 4, 5 ], [ 1, 2, 4, 5 ], 
  [ 1, 2, 3, 5 ], [ 1, 2, 3, 4 ] ] ) )
</pre></div>

<p><a id="X7F44B86582CCC23D" name="X7F44B86582CCC23D"></a></p>

<h5>B.4-11 DistanceMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DistanceMatrix</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the distance matrix <code class="code">D</code> of a graph <var class="Arg">G</var>: <code class="code">D[x][y]</code> is the distance in <var class="Arg">G</var> from vertex <code class="code">x</code> to vertex <code class="code">y</code>. The matrix may be asymmetric if the graph is not simple. An infinite entry in the matrix means that there is no path between the vertices. Floyd's algorithm is used to compute the matrix.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(DistanceMatrix(g));</span>
[ [  0,  1,  2,  3 ],
  [  1,  0,  1,  2 ],
  [  2,  1,  0,  1 ],
  [  3,  2,  1,  0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(4:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2 ], [ 3 ], [ 4 ], [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(DistanceMatrix(g));                   </span>
[ [         0,         1,         2,         3 ],
  [  infinity,         0,         1,         2 ],
  [  infinity,  infinity,         0,         1 ],
  [  infinity,  infinity,  infinity,         0 ] ]
</pre></div>

<p><a id="X845639757F540AF7" name="X845639757F540AF7"></a></p>

<h5>B.4-12 DistanceSet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DistanceSet</code>( <var class="Arg">G</var>, <var class="Arg">A</var>, <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given two subsets of vertices <var class="Arg">A</var>, <var class="Arg">B</var> of a graph <var class="Arg">G</var>, <code class="code">DistanceSet</code> returns the set of distances for every pair in the Cartesian product of <var class="Arg">A</var> and <var class="Arg">B</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(5);;         </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DistanceSet(g, [1,3], [2,4]);</span>
[ 1, 2 ]
</pre></div>

<p><a id="X81A6D8FE876EB3BE" name="X81A6D8FE876EB3BE"></a></p>

<h5>B.4-13 Dodecahedron</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Dodecahedron</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The 1-skeleton of Plato's dodecahedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dodecahedron;</span>
Graph( rec( Category := SimpleGraphs, Order := 20, Size := 
30, Adjacencies := [ [ 2, 5, 6 ], [ 1, 3, 7 ], [ 2, 4, 8 ], 
  [ 3, 5, 9 ], [ 1, 4, 10 ], [ 1, 11, 15 ], [ 2, 11, 12 ], 
  [ 3, 12, 13 ], [ 4, 13, 14 ], [ 5, 14, 15 ], [ 6, 7, 16 ], 
  [ 7, 8, 17 ], [ 8, 9, 18 ], [ 9, 10, 19 ], [ 6, 10, 20 ], 
  [ 11, 17, 20 ], [ 12, 16, 18 ], [ 13, 17, 19 ], [ 14, 18, 20 ], 
  [ 15, 16, 19 ] ] ) )
</pre></div>

<p><a id="X7E8FE6A887FEFED1" name="X7E8FE6A887FEFED1"></a></p>

<h5>B.4-14 DominatedVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominatedVertices</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the set of dominated vertices of <var class="Arg">G</var>.</p>

<p>A vertex <code class="code">x</code> is dominated by another vertex <code class="code">y</code> when the closed neighborhood of <code class="code">x</code> is contained in that of <code class="code">y</code>. However, when there are twin vertices (mutually dominated vertices), exactly one of them (in each equivalent class of mutually dominated vertices) does not appear in the returned set.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=PathGraph(3);     </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominatedVertices(g1);</span>
[ 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:=PathGraph(2);</span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominatedVertices(g2);</span>
[ 2 ]
</pre></div>

<p><a id="X7F28DFDE83BB127C" name="X7F28DFDE83BB127C"></a></p>

<h5>B.4-15 DominoGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominoGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>Two squares glued by an edge.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominoGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
7, Adjacencies := [ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], 
  [ 4, 6 ], [ 1, 5 ] ] ) )
</pre></div>

<p><a id="X7DF9F3AD86602DFC" name="X7DF9F3AD86602DFC"></a></p>

<h5>B.4-16 Draw</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Draw</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Draw</code>( <var class="Arg">G</var>, <var class="Arg">Highlighted</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Takes a graph <var class="Arg">G</var> and makes a drawing of it in a separate window possibly with a list of <var class="Arg">Highlighted</var> vertices. The user can then view and modify the drawing and finally save the vertex coordinates of the drawing into the graph <var class="Arg">G</var>.</p>

<p>Within the separate window, type h to toggle on/off the help menu. Besides the keyboard commands indicated in the help menu, the user may also move vertices (by dragging them), move the whole drawing (by dragging the background) and scale the drawing (by using the mouse wheel).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(Icosahedron);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Draw(Icosahedron);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(Icosahedron);</span>
[ [ 29, -107 ], [ 65, -239 ], [ 240, -62 ], [ 78, 79 ], [ -107, 28 ], 
  [ -174, -176 ], [ -65, 239 ], [ -239, 62 ], [ -78, -79 ], [ 107, -28 ], 
  [ 174, 176 ], [ -29, 107 ] ]
</pre></div>

<p>In its second form, <var class="Arg">Highlighted</var> is a list of vertices of <var class="Arg">G</var> and those vertices are drawn in a highlighted color by <code class="code">Draw()</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Draw(Cube,[1,4,6,7]);</span>
</pre></div>

<p><code class="code">Draw()</code> uses an external Java program (included with <strong class="pkg">YAGS</strong>) and hence, may not work on some platforms.</p>

<p>Current version has been tested successfully on GNU/Linux, Mac OS X and Windows7. For other platforms (specially 32-bit platforms), you should probably (at least) set up correctly the variables <code class="code">YAGSInfo.Draw.prog</code> and <code class="code">YAGSInfo.Draw.opts</code>. The former is a string representing the external binary program path and name; the latter is a list of strings representing the required command line options. Java binaries are provided for 32 and 64 bit versions of GNU/Linux (which also works for Mac OS X) and of MS Windows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">YAGSInfo.Draw.prog; YAGSInfo.Draw.opts;</span>
"/opt/gap-4.10.2/pkg/yags/bin/draw/application.linux64/draw"
[  ]
</pre></div>

<p>The source code for the external program, made using <em>processing</em> (<span class="URL"><a href="http://processing.org">http://processing.org</a></span> version 2.2.1; version 3 is not working well for us), is <code class="file">YAGS-DIR/bin/draw/draw.pde</code></p>

<p><a id="X7C9C16068556896D" name="X7C9C16068556896D"></a></p>

<h5>B.4-17 DumpObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DumpObject</code>( <var class="Arg">Obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Dumps all information available for object <var class="Arg">Obj</var>. This information includes to which categories it belongs as well as its type and hashing information used by <strong class="pkg">GAP</strong>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DumpObject( true );</span>
Object( TypeObj := NewType( NewFamily( "BooleanFamily", [ 11 ], [ 11 ] ),
[ 11, 34 ] ), Categories := [ "IS_BOOL" ] )
</pre></div>

<p><a id="X8631458886314588" name="X8631458886314588"></a></p>

<h4>B.5 <span class="Heading">E</span></h4>

<p><a id="X7ECEE52778A8C925" name="X7ECEE52778A8C925"></a></p>

<h5>B.5-1 EasyExec</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EasyExec</code>( <var class="Arg">Dir</var>, <var class="Arg">ProgName</var>, <var class="Arg">InString</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EasyExec</code>( <var class="Arg">ProgName</var>, <var class="Arg">InString</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Calls external program <var class="Arg">ProgName</var> located in directory <var class="Arg">Dir</var>, feeding it with <var class="Arg">InString</var> as input and returning the output of the external program as a string. <var class="Arg">Dir</var> must be a directory object or a list of directory objects. If <var class="Arg">Dir</var> is not provided, <var class="Arg">ProgName</var> must be in the system's binary PATH. If the program could not be located, <code class="code">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:=EasyExec("date","");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s;</span>
"Sun Nov  9 10:36:16 CST 2014\n"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:=EasyExec("sort","4\n2\n3\n1");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s;</span>
"1\n2\n3\n4\n"
</pre></div>

<p>This operation have not been tested on MS Windows.</p>

<p><a id="X807111A07D9E4838" name="X807111A07D9E4838"></a></p>

<h5>B.5-2 Eccentricity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eccentricity</code>( <var class="Arg">G</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the distance from a vertex <var class="Arg">x</var> in graph <var class="Arg">G</var> to its most distant vertex in <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Eccentricity(g,1);           </span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Eccentricity(g,3);</span>
2
</pre></div>

<p><a id="X805DA3C47BF09BD1" name="X805DA3C47BF09BD1"></a></p>

<h5>B.5-3 Edges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Edges</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of edges of the graph <var class="Arg">G</var> in the case of <code class="code">SimpleGraphs</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=CompleteGraph(3);     </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
3, Adjacencies := [ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Edges(g1);</span>
[ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]
</pre></div>

<p>In the case of <code class="code">UndirectedGraphs</code>, it also returns the loops. While in the other categories, <code class="code">Edges</code> actually does not return the edges, but the loops and arrows of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:=CompleteGraph(3:GraphCategory:=UndirectedGraphs);</span>
Graph( rec( Category := UndirectedGraphs, Order := 3, Size := 
6, Adjacencies := [ [ 1, 2, 3 ], [ 1, 2, 3 ], [ 1, 2, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Edges(g2);</span>
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ], [ 3, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g3:=CompleteGraph(3:GraphCategory:=Graphs);          </span>
Graph( rec( Category := Graphs, Order := 3, Size := 9, Adjacencies := 
[ [ 1, 2, 3 ], [ 1, 2, 3 ], [ 1, 2, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Edges(g3);                                 </span>
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], 
  [ 3, 1 ], [ 3, 2 ], [ 3, 3 ] ]
</pre></div>

<p><a id="X7D8CF4F57FC21A97" name="X7D8CF4F57FC21A97"></a></p>

<h5>B.5-4 EmptyGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmptyGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The graph on zero vertices and zero edges. The empty graph has conventional values for its attributes as shown in the examples.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EmptyGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 0, Size := 
0, Adjacencies := [  ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Diameter(EmptyGraph);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaxDegree(EmptyGraph);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinDegree(EmptyGraph);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(EmptyGraph);</span>
infinity
</pre></div>

<p><a id="X7E1A57287D9C4ECE" name="X7E1A57287D9C4ECE"></a></p>

<h5>B.5-5 EquivalenceRepresentatives</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EquivalenceRepresentatives</code>( <var class="Arg">L</var>, <var class="Arg">Eqiv</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a sublist of <var class="Arg">L</var>, which is a complete list of representatives of <var class="Arg">L</var> under the equivalent relation <var class="Arg">Equiv</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=[10,2,6,5,9,7,3,1,4,8];</span>
[ 10, 2, 6, 5, 9, 7, 3, 1, 4, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquivalenceRepresentatives(L,function(x,y) return (x mod 4)=(y mod 4); end);</span>
[ 10, 5, 7, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=Links(SnubDisphenoid);;Length(L);</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=EquivalenceRepresentatives(L,IsIsomorphicGraph);;Length(L); </span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L;</span>
[ Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], 
      [ 1, 4 ] ] ) ), Graph( rec( Category := SimpleGraphs, Order := 
    4, Size := 4, Adjacencies := [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], 
      [ 2, 3 ] ] ) ) ]
</pre></div>

<p><a id="X805A4A907A37EADE" name="X805A4A907A37EADE"></a></p>

<h5>B.5-6 ExportGraph6</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExportGraph6</code>( <var class="Arg">Filename</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExportGraph6</code>( <var class="Arg">Filename</var>, <var class="Arg">L</var>, <var class="Arg">overwrite</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Appends to <var class="Arg">Filename</var> the list strings representing the graphs in the list <var class="Arg">L</var> using Brendan McKay's graph6 format. <var class="Arg">Filename</var> is created first if necessary. This operation allows us to create databases which use this format. Several such databases can be found here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html">https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html</a></span>.</p>

<p>The graph6 format is described here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt">https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt</a></span>.</p>

<p>If <var class="Arg">overwrite</var> is present, and it is <code class="code">true</code>, the file <var class="Arg">Filename</var> is emptied first. If <var class="Arg">overwrite</var> is <code class="code">false</code>, the new data is appended to <var class="Arg">Filename</var> (the default behavior).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=List([1..5],z-&gt;RandomGraph(5));</span>
[ Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    2, Adjacencies := [ [ 2, 3 ], [ 1 ], [ 1 ], [  ], [  ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    5, Adjacencies := [ [ 4, 5 ], [ 3 ], [ 2, 4, 5 ], [ 1, 3 ], [ 1, 3 ] 
     ] ) ), Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    4, Adjacencies := [ [ 2, 4 ], [ 1, 3, 4 ], [ 2 ], [ 1, 2 ], [  ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    6, Adjacencies := [ [ 3, 5 ], [ 3, 5 ], [ 1, 2, 5 ], [ 5 ], 
      [ 1, 2, 3, 4 ] ] ) ), Graph( rec( Category := SimpleGraphs, Order := 
    5, Size := 6, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 5 ], 
      [ 1 ], [ 1, 3 ] ] ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExportGraph6("test.g6",L,true);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:=ImportGraph6("test.g6");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..5],i-&gt;L[i]=S[i]);</span>
[ true, true, true, true, true ]
</pre></div>

<p>See also <code class="func">GraphToGraph6</code> (<a href="chapB.html#X7C5F2B6D86D1DCF5"><span class="RefLink">B.7-16</span></a>), <code class="func">ImportGraph6</code> (<a href="chapB.html#X7DF0F8C079D7D07D"><span class="RefLink">B.9-2</span></a>).</p>

<p><a id="X7FA1D0937FA1D093" name="X7FA1D0937FA1D093"></a></p>

<h4>B.6 <span class="Heading">F</span></h4>

<p><a id="X87CA7A5782928649" name="X87CA7A5782928649"></a></p>

<h5>B.6-1 FanGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FanGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the <var class="Arg">n</var>-fan: The join of a vertex and a <var class="Arg">(n+1)</var>-path.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FanGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
9, Adjacencies := [ [ 2, 3, 4, 5, 6 ], [ 1, 3 ], [ 1, 2, 4 ], 
  [ 1, 3, 5 ], [ 1, 4, 6 ], [ 1, 5 ] ] ) )
</pre></div>

<p><a id="X7DC9D4FA8791956D" name="X7DC9D4FA8791956D"></a></p>

<h5>B.6-2 FishGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FishGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A square and a triangle glued by a vertex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FishGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
7, Adjacencies := [ [ 2, 3, 4, 6 ], [ 1, 3 ], [ 1, 2 ], [ 1, 5 ], 
  [ 4, 6 ], [ 1, 5 ] ] ) )
</pre></div>

<p><a id="X78D1A39A78D1A39A" name="X78D1A39A78D1A39A"></a></p>

<h4>B.7 <span class="Heading">G</span></h4>

<p><a id="X7C2D6F35838052F5" name="X7C2D6F35838052F5"></a></p>

<h5>B.7-1 GemGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GemGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The 3-fan graph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GemGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
7, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], 
  [ 1, 3, 5 ], [ 1, 4 ] ] ) )
</pre></div>

<p><a id="X84E213C9801D1558" name="X84E213C9801D1558"></a></p>

<h5>B.7-2 Girth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Girth</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the length of a minimum cycle in <var class="Arg">G</var>. At this time, <code class="code">Girth</code> is defined only for <code class="func">SimpleGraphs</code> (<a href="chapB.html#X786FE7C97A76D747"><span class="RefLink">B.19-3</span></a>) and <code class="func">UndirectedGraphs</code> (<a href="chapB.html#X7CC6D5C77C0CCFA3"><span class="RefLink">B.21-3</span></a>). If <var class="Arg">G</var> has loops, its girth is 1 by definition.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(Octahedron);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(PetersenGraph);         </span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(Cube);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(PathGraph(5));</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=AddEdges(CycleGraph(4),[[3,3]]:GraphCategory:=UndirectedGraphs);</span>
Graph( rec( Category := UndirectedGraphs, Order := 4, Size := 
5, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 3, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(g);            </span>
1
</pre></div>

<p><a id="X7B335342839E5146" name="X7B335342839E5146"></a></p>

<h5>B.7-3 Graph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Graph</code>( <var class="Arg">Rec</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a new graph created from the record <var class="Arg">Rec</var>. The record must provide the field <var class="Arg">Category</var> and either the field <var class="Arg">Adjacencies</var> or the field <var class="Arg">AdjMatrix</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Graph(rec(Category:=SimpleGraphs,Adjacencies:=[[2],[1]]));</span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Graph(rec(Category:=SimpleGraphs,AdjMatrix:=[[false, true],[true, false]]));</span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
</pre></div>

<p>Its main purpose is to import graphs from files, which could have been previously exported using <code class="code">PrintTo</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(g);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintTo("aux.g","h:=",g,";");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Read("aux.g");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h;</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
</pre></div>

<p><a id="X84BA39B986A7A8F7" name="X84BA39B986A7A8F7"></a></p>

<h5>B.7-4 GraphAttributeStatistics</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphAttributeStatistics</code>( <var class="Arg">OrderList</var>, <var class="Arg">ProbList</var>, <var class="Arg">Attribute</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns statistics for graph attribute <var class="Arg">Attribute</var>. For each of the orders <var class="Arg">n</var> in <var class="Arg">OrderList</var> and for each of the probabilities <var class="Arg">p</var> in <var class="Arg">ProbList</var> this function generates 100 random graphs of order <var class="Arg">n</var> and edge probability <var class="Arg">p</var> and then evaluates the graph attribute <var class="Arg">Attribute</var> on each of them. The function then returns statistical data on these experiments. The form in which the statistical data is reported depend on a number of issues and is best explained by examples.</p>

<p>First let us consider the case where <var class="Arg">Attribute</var> is a Boolean attribute (always returns <code class="code">true</code> or <code class="code">false</code>) and where <var class="Arg">OrderList</var> and <var class="Arg">ProbList</var> consist of a unique value. In this case, the respective lists may be replaced by the corresponding unique values on invocation:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphAttributeStatistics(10,1/2,IsCliqueHelly);</span>
32
</pre></div>

<p>This tells us that 32 of the 100 examined random graphs resulted to be clique-Helly; The random sample was constructed using graphs of order 10 and edge probability 1/2.</p>

<p>Now we can specify a list of probabilities to be examined:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphAttributeStatistics(10,1/10*[1..9],IsCliqueHelly);</span>
[ 100, 100, 94, 63, 34, 16, 30, 76, 95 ]
</pre></div>

<p>The last example tells us that, for graphs on 10 vertices, the property IsCliqueHelly is least probable to be true for graphs with edge probabilities 5/10 6/10 and 7/10, being 6/10 the probability that reaches the minimum in the random sample. Note that the 34 in the previous example does not match the 32 in the first one, this is to be expected as the statistics are compiled from a random sample of graphs. Also, note that in the previous example, 900 random graphs where generated and examined.</p>

<p>We can also specify a list of orders to consider:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphAttributeStatistics([10,12..20],1/10*[1..9],IsCliqueHelly);</span>
[ [ 100, 100, 92, 62, 37, 16, 36, 70, 97 ], 
  [ 100, 99, 83, 34, 8, 1, 19, 68, 97 ], 
  [ 100, 96, 54, 4, 2, 0, 6, 54, 98 ], 
  [ 100, 89, 26, 2, 0, 0, 9, 42, 96 ], 
  [ 100, 70, 13, 1, 0, 0, 6, 24, 94 ], 
  [ 99, 70, 5, 0, 0, 0, 4, 22, 92 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
[ [  100,  100,   92,   62,   37,   16,   36,   70,   97 ],
  [  100,   99,   83,   34,    8,    1,   19,   68,   97 ],
  [  100,   96,   54,    4,    2,    0,    6,   54,   98 ],
  [  100,   89,   26,    2,    0,    0,    9,   42,   96 ],
  [  100,   70,   13,    1,    0,    0,    6,   24,   94 ],
  [   99,   70,    5,    0,    0,    0,    4,   22,   92 ] ]
</pre></div>

<p>Which tell us that the observed bimodal distribution is even more pronounced when the order of the graphs considered grows.</p>

<p>In the case of a non-Boolean attribute <code class="code">GraphAttributeStatistics()</code> reports the values that <var class="Arg">Attribute</var> took on the sample as well as the number of times that each of these values where obtained:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphAttributeStatistics(10,1/2,Diameter);     </span>
[ [ 2, 34 ], [ 3, 59 ], [ 4, 5 ], [ 5, 1 ], [ infinity, 1 ] ]
</pre></div>

<p>The returned statistics mean that among the 100 generated random graphs on 10 vertices with edge probability 1/2, there were 34 graphs with diameter 2, 59 graphs of diameter 3, 5 of 4, 1 of 5 and there was one graph which was not connected.</p>

<p>Now it should be evident the format of the returned statistics when we specify a list of probabilities and/or a list of orders to be considered for a non-Boolean <var class="Arg">Attribute</var>:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphAttributeStatistics(10,1/5*[1..4],Diameter);         </span>
[ [ [ 3, 1 ], [ 4, 7 ], [ 5, 8 ], [ 6, 6 ], [ infinity, 78 ] ], 
  [ [ 2, 6 ], [ 3, 55 ], [ 4, 21 ], [ 5, 1 ], [ 6, 1 ], 
      [ infinity, 16 ] ], [ [ 2, 74 ], [ 3, 25 ], [ 4, 1 ] ], 
  [ [ 2, 100 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphAttributeStatistics([10,12,14],1/5*[1..4],Diameter);</span>
[ [ [ [ 3, 2 ], [ 4, 8 ], [ 5, 11 ], [ 6, 5 ], [ 7, 1 ], 
          [ infinity, 73 ] ], 
      [ [ 2, 6 ], [ 3, 56 ], [ 4, 23 ], [ 5, 7 ], [ infinity, 8 ] ], 
      [ [ 2, 72 ], [ 3, 27 ], [ infinity, 1 ] ], 
      [ [ 2, 99 ], [ 3, 1 ] ] ], 
  [ 
      [ [ 3, 4 ], [ 4, 13 ], [ 5, 10 ], [ 6, 6 ], [ 7, 3 ], 
          [ infinity, 64 ] ], 
      [ [ 2, 7 ], [ 3, 69 ], [ 4, 17 ], [ infinity, 7 ] ], 
      [ [ 2, 76 ], [ 3, 24 ] ], [ [ 2, 100 ] ] ], 
  [ [ [ 4, 12 ], [ 5, 16 ], [ 6, 7 ], [ 7, 3 ], [ infinity, 62 ] ], 
      [ [ 2, 8 ], [ 3, 86 ], [ 4, 4 ], [ infinity, 2 ] ], 
      [ [ 2, 86 ], [ 3, 14 ] ], [ [ 2, 100 ] ] ] ]
</pre></div>

<p><a id="X7DE40F478257F31A" name="X7DE40F478257F31A"></a></p>

<h5>B.7-5 Graph6ToGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Graph6ToGraph</code>( <var class="Arg">String</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the graph represented by <var class="Arg">String</var> which is encoded using Brendan McKay's graph6 format. This operation allows us to read data in databases which use this format. Several such databases can be found here: <span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html">https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html</a></span>.</p>

<p>The graph6 format is described here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt">https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt</a></span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Graph6ToGraph("D?{");    </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 5 ], [ 5 ], [ 5 ], [ 5 ], [ 1, 2, 3, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Graph6ToGraph("FUzvW");  </span>
Graph( rec( Category := SimpleGraphs, Order := 7, Size := 
15, Adjacencies := [ [ 3, 4, 5, 6, 7 ], [ 4, 5, 6, 7 ], 
  [ 1, 5, 6, 7 ], [ 1, 2, 6 ], [ 1, 2, 3, 7 ], [ 1, 2, 3, 4, 7 ], 
  [ 1, 2, 3, 5, 6 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Graph6ToGraph("HUzv~z}");</span>
Graph( rec( Category := SimpleGraphs, Order := 9, Size := 
29, Adjacencies := [ [ 3, 4, 5, 6, 7, 8, 9 ], [ 4, 5, 6, 7, 8, 9 ], 
  [ 1, 5, 6, 7, 8, 9 ], [ 1, 2, 6, 7, 8, 9 ], [ 1, 2, 3, 7, 8, 9 ], 
  [ 1, 2, 3, 4, 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 9 ], 
  [ 1, 2, 3, 4, 5, 6 ], [ 1, 2, 3, 4, 5, 6, 7 ] ] ) )
</pre></div>

<p>See also <code class="func">ImportGraph6</code> (<a href="chapB.html#X7DF0F8C079D7D07D"><span class="RefLink">B.9-2</span></a>).</p>

<p><a id="X8522B1957D17741E" name="X8522B1957D17741E"></a></p>

<h5>B.7-6 GraphByAdjacencies</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphByAdjacencies</code>( <var class="Arg">AdjList</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a new graph having <var class="Arg">AdjList</var> as its list of adjacencies. The order of the created graph is <code class="code">Length(<var class="Arg">AdjList</var>)</code>, and the set of neighbors of vertex <var class="Arg">x</var> is <span class="SimpleMath"><var class="Arg">AdjList</var>[<var class="Arg">x</var>]</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByAdjacencies([[2],[1,3],[2]]);      </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
</pre></div>

<p>Note, however, that the graph is forced to comply with the <code class="code">TargetGraphCategory</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByAdjacencies([[1,2,3],[],[]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2, 3 ], [ 1 ], [ 1 ] ] ) )
</pre></div>

<p><a id="X7F2479B8805852DC" name="X7F2479B8805852DC"></a></p>

<h5>B.7-7 GraphByAdjMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphByAdjMatrix</code>( <var class="Arg">Mat</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a new graph created from an adjacency matrix <var class="Arg">Mat</var>. The matrix <var class="Arg">Mat</var> must be a square boolean matrix.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:=[ [ false, true, false ], [ true, false, true ], [ false, true, false ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=GraphByAdjMatrix(m);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjMatrix(g);</span>
[ [ false, true, false ], [ true, false, true ], 
  [ false, true, false ] ]
</pre></div>

<p>Note, however, that the graph is forced to comply with the <code class="code">TargetGraphCategory</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:=[ [ true, true], [ false, false ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=GraphByAdjMatrix(m);                </span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjMatrix(g);                          </span>
[ [ false, true ], [ true, false ] ]
</pre></div>

<p><a id="X7CDF55C37DA5F76B" name="X7CDF55C37DA5F76B"></a></p>

<h5>B.7-8 GraphByCompleteCover</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphByCompleteCover</code>( <var class="Arg">Cover</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the minimal graph where the elements of <var class="Arg">Cover</var> are (the vertex sets of) complete subgraphs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByCompleteCover([[1,2,3,4],[4,6,7]]); </span>
Graph( rec( Category := SimpleGraphs, Order := 7, Size := 
9, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3, 6, 7 ], [  ], [ 4, 7 ], [ 4, 6 ] ] ) )
</pre></div>

<p><a id="X82FE32A97F0F049F" name="X82FE32A97F0F049F"></a></p>

<h5>B.7-9 GraphByEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphByEdges</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the minimal graph such that the pairs in <var class="Arg">L</var> are edges.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByEdges([[1,2],[1,3],[1,4],[4,5]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 2, 3, 4 ], [ 1 ], [ 1 ], [ 1, 5 ], [ 4 ] ] ) )
</pre></div>

<p>The vertices of the constructed graph range from 1 to the maximum of the numbers appearing in <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByEdges([[4,3],[4,5]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
2, Adjacencies := [ [  ], [  ], [ 4 ], [ 3, 5 ], [ 4 ] ] ) )
</pre></div>

<p>Note that <code class="func">GraphByWalks</code> (<a href="chapB.html#X790CBDC282E6FEA1"><span class="RefLink">B.7-11</span></a>) can do the same and much more.</p>

<p><a id="X87040937831AA788" name="X87040937831AA788"></a></p>

<h5>B.7-10 GraphByRelation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphByRelation</code>( <var class="Arg">V</var>, <var class="Arg">Rel</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphByRelation</code>( <var class="Arg">n</var>, <var class="Arg">Rel</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a new graph created from a set of vertices <var class="Arg">V</var> and a binary relation <var class="Arg">Rel</var>, where <span class="SimpleMath">x∼ y</span> iff <code class="code"><var class="Arg">Rel</var>(x,y)=true</code>. In the second form, <var class="Arg">n</var> is an integer and <span class="SimpleMath">V</span> is assumed to be <span class="SimpleMath">{1, 2, ..., n}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rel:=function(x,y) return Intersection(x,y)&lt;&gt;[]; end;;          </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByRelation([[1,2,3],[3,4,5],[5,6,7]],Rel);               </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByRelation(8,function(x,y) return AbsInt(x-y)&lt;=2; end); </span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
13, Adjacencies := [ [ 2, 3 ], [ 1, 3, 4 ], [ 1, 2, 4, 5 ], 
  [ 2, 3, 5, 6 ], [ 3, 4, 6, 7 ], [ 4, 5, 7, 8 ], [ 5, 6, 8 ], 
  [ 6, 7 ] ] ) )
</pre></div>

<p><a id="X790CBDC282E6FEA1" name="X790CBDC282E6FEA1"></a></p>

<h5>B.7-11 GraphByWalks</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphByWalks</code>( <var class="Arg">Walk1</var>, <var class="Arg">Walk2</var>, <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the minimal graph such that <var class="Arg">Walk1</var>, <var class="Arg">Walk2</var>, etc are Walks.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,2,3,4,1],[1,5,6]);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
6, Adjacencies := [ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], 
  [ 1, 6 ], [ 5 ] ] ) )
</pre></div>

<p>Walks can be <var class="Arg">nested</var>, which greatly improves the versatility of this function.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,[2,3,4],5],[5,6]);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
9, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 5 ], [ 1, 2, 4, 5 ], 
  [ 1, 3, 5 ], [ 2, 3, 4, 6 ], [ 5 ] ] ) )
</pre></div>

<p>The vertices in the constructed graph range from 1 to the maximum of the numbers appearing in <var class="Arg">Walk1</var>, <var class="Arg">Walk2</var>, ... etc.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([4,2],[3,6]);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
2, Adjacencies := [ [  ], [ 4 ], [ 6 ], [ 2 ], [  ], [ 3 ] ] ) )
</pre></div>

<p><a id="X7D06ED35855A69E1" name="X7D06ED35855A69E1"></a></p>

<h5>B.7-12 GraphCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphCategory</code>( [<var class="Arg">G</var>, <var class="Arg">...</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For internal use. Returns the minimal common graph category to a list of graphs. If the list of graphs is empty, the default category is returned. The partial order (by inclusion) among graph categories is as follows:</p>


<pre class="normal">

                Graphs
              /        \    
UndirectedGraphs      LooplessGraphs
              \        /          \       
             SimpleGraphs        OrientedGraphs

</pre>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=CompleteGraph(2:GraphCategory:=SimpleGraphs);  </span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:=CompleteGraph(2:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g3:=CompleteGraph(2:GraphCategory:=UndirectedGraphs);</span>
Graph( rec( Category := UndirectedGraphs, Order := 2, Size := 
3, Adjacencies := [ [ 1, 2 ], [ 1, 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphCategory([g1,g2,g3]);</span>
&lt;Category "Graphs"&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphCategory([g1,g2]);   </span>
&lt;Category "LooplessGraphs"&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphCategory([g1,g3]);</span>
&lt;Category "UndirectedGraphs"&gt;
</pre></div>

<p><a id="X815691877F8C800C" name="X815691877F8C800C"></a></p>

<h5>B.7-13 Graphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Graphs</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">Graphs</code> is the most general graph category in <strong class="pkg">YAGS</strong>. This category contains all graphs that can be represented in <strong class="pkg">YAGS</strong>. A graph in this category may contain loops, arrows and edges (which in <strong class="pkg">YAGS</strong> are exactly the same as two opposite arrows between some pair of vertices). This graph category has no parent category.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);</span>
Graph( rec( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=SimpleGraphs);  </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X7F66DFB17CC3B2D9" name="X7F66DFB17CC3B2D9"></a></p>

<h5>B.7-14 GraphsOfGivenOrder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphsOfGivenOrder</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of all graphs of order <var class="Arg">n</var> (up to isomorphism). This operation uses Brendan McKay's data published here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html">https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html</a></span>.</p>

<p>These data are included with the <strong class="pkg">YAGS</strong> distribution in its <code class="code">data</code> directory. Hence this operation simply reads the corresponding file in that directory using <code class="code">ImportGraph6( <var class="Arg">Filename</var> )</code>. Therefore, the integer <var class="Arg">n</var> must be in the range from 1 up to 9.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphsOfGivenOrder(2);          </span>
[ Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
    0, Adjacencies := [ [  ], [  ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
    1, Adjacencies := [ [ 2 ], [ 1 ] ] ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphsOfGivenOrder(3);</span>
[ Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
    0, Adjacencies := [ [  ], [  ], [  ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
    1, Adjacencies := [ [ 3 ], [  ], [ 1 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
    2, Adjacencies := [ [ 3 ], [ 3 ], [ 1, 2 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
    3, Adjacencies := [ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ] ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(GraphsOfGivenOrder(9));</span>
274668
</pre></div>

<p>Data for graphs on 10 vertices is also available, but not included with <strong class="pkg">YAGS</strong>, it may not be practical to use that data, but if you would like to try, all you have to do is to copy (and to uncompress) the corresponding file into the directory <code class="file">YAGS-DIR/data/</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphsOfGivenOrder(10);       </span>
#W Unreadable File: /opt/gap-4.10.2/pkg/yags/data/graph10.g6
fail
</pre></div>

<p><a id="X7E8B61AD787C430F" name="X7E8B61AD787C430F"></a></p>

<h5>B.7-15 GraphSum</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphSum</code>( <var class="Arg">G</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the lexicographic sum of a list of graphs <var class="Arg">L</var> over a graph <var class="Arg">G</var>.</p>

<p>The lexicographic sum is computed as follows:</p>

<p>Given <var class="Arg">G</var>, with <span class="SimpleMath">Order( <var class="Arg">G</var> )=n</span> and a list of <span class="SimpleMath">n</span> graphs <span class="SimpleMath"><var class="Arg">L</var> = [G_1, ..., G_n]</span>, we take the disjoint union of <span class="SimpleMath">G_1,G_2, ...,G_n</span> and then we add all the edges between <span class="SimpleMath">G_i</span> and <span class="SimpleMath">G_j</span> whenever <span class="SimpleMath">[i,j]</span> is and edge of <var class="Arg">G</var>.</p>

<p>If <var class="Arg">L</var> contains holes, the trivial graph is used in place.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:=TrivialGraph;; g:=CycleGraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphSum(PathGraph(3),[t,g,t]);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 5, 6 ], [ 1, 2, 4, 6 ], 
  [ 1, 3, 5, 6 ], [ 1, 2, 4, 6 ], [ 2, 3, 4, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphSum(PathGraph(3),[,g,]);  </span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 5, 6 ], [ 1, 2, 4, 6 ], 
  [ 1, 3, 5, 6 ], [ 1, 2, 4, 6 ], [ 2, 3, 4, 5 ] ] ) )
</pre></div>

<p><a id="X7C5F2B6D86D1DCF5" name="X7C5F2B6D86D1DCF5"></a></p>

<h5>B.7-16 GraphToGraph6</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphToGraph6</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the <var class="Arg">String</var> which represents the graph <var class="Arg">G</var> using Brendan McKay's graph6 format. This operation allows us to create databases using this format. Several such databases can be found here: <span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html">https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html</a></span>.</p>

<p>The graph6 format is described here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt">https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt</a></span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Graph6ToGraph("D?{");    </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 5 ], [ 5 ], [ 5 ], [ 5 ], [ 1, 2, 3, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Graph6ToGraph("FUzvW");  </span>
Graph( rec( Category := SimpleGraphs, Order := 7, Size := 
15, Adjacencies := [ [ 3, 4, 5, 6, 7 ], [ 4, 5, 6, 7 ], 
  [ 1, 5, 6, 7 ], [ 1, 2, 6 ], [ 1, 2, 3, 7 ], [ 1, 2, 3, 4, 7 ], 
  [ 1, 2, 3, 5, 6 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Graph6ToGraph("HUzv~z}");</span>
Graph( rec( Category := SimpleGraphs, Order := 9, Size := 
29, Adjacencies := [ [ 3, 4, 5, 6, 7, 8, 9 ], [ 4, 5, 6, 7, 8, 9 ], 
  [ 1, 5, 6, 7, 8, 9 ], [ 1, 2, 6, 7, 8, 9 ], [ 1, 2, 3, 7, 8, 9 ], 
  [ 1, 2, 3, 4, 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 9 ], 
  [ 1, 2, 3, 4, 5, 6 ], [ 1, 2, 3, 4, 5, 6, 7 ] ] ) )
</pre></div>

<p>See also <code class="func">ExportGraph6</code> (<a href="chapB.html#X805A4A907A37EADE"><span class="RefLink">B.5-6</span></a>) and <code class="func">Graph6ToGraph</code> (<a href="chapB.html#X7DE40F478257F31A"><span class="RefLink">B.7-5</span></a>).</p>

<p><a id="X8661587880C12114" name="X8661587880C12114"></a></p>

<h5>B.7-17 GraphToRaw</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphToRaw</code>( <var class="Arg">FileName</var>, <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphToRaw</code>( <var class="Arg">FileName</var>, <var class="Arg">G</var>, <var class="Arg">Highlighted</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Converts a <strong class="pkg">YAGS</strong> graph <var class="Arg">G</var> into a raw format (number of vertices, coordinates, adjacency matrix, number of highlighted vertices and list of highlighted vertices) and writes the converted data to the file <var class="Arg">FileName</var>. For use by the external program <code class="code">draw</code> (see <code class="func">Draw</code> (<a href="chapB.html#X7DF9F3AD86602DFC"><span class="RefLink">B.4-16</span></a>) ). Intended for internal use only.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:=CycleGraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphToRaw("mygraph.raw",G);</span>
</pre></div>

<p>If <var class="Arg">Highlighted</var> is not specified, it is assumed to be the empty list. The vertices listed in <var class="Arg">Highlighted</var> are drawn in a highlighted color by <code class="code">Draw()</code>.</p>

<p><a id="X793E67DD83402749" name="X793E67DD83402749"></a></p>

<h5>B.7-18 GraphUpdateFromRaw</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphUpdateFromRaw</code>( <var class="Arg">FileName</var>, <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Updates the coordinates of <var class="Arg">G</var> from a file <var class="Arg">FileName</var> in raw format as written by <code class="code">draw</code> (see <code class="func">Draw</code> (<a href="chapB.html#X7DF9F3AD86602DFC"><span class="RefLink">B.4-16</span></a>) ). Intended for internal use only.</p>

<p><a id="X78BA06B387DA3279" name="X78BA06B387DA3279"></a></p>

<h5>B.7-19 GroupGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupGraph</code>( <var class="Arg">G</var>, <var class="Arg">Grp</var>, <var class="Arg">Act</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupGraph</code>( <var class="Arg">G</var>, <var class="Arg">Grp</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given a graph <var class="Arg">G</var>, a group <var class="Arg">Grp</var> and an action <var class="Arg">Act</var> of <var class="Arg">Grp</var> on some set S which contains <span class="SimpleMath">Vertices( <var class="Arg">G</var> )</span>, <code class="code">GroupGraph</code> returns a new graph with vertex set <span class="SimpleMath">{<var class="Arg">Act</var>(v,g) : g ∈ <var class="Arg">Grp</var>, v ∈ Vertices( <var class="Arg">G</var> )}</span> and edge set <span class="SimpleMath">{{<var class="Arg">Act</var>(v,g),<var class="Arg">Act</var>(u,g)}: g∈ <var class="Arg">Grp</var>, {u,v}∈ Edges( <var class="Arg">G</var> )}</span>.</p>

<p>If <var class="Arg">Act</var> is omitted, the standard <strong class="pkg">GAP</strong> action <code class="code">OnPoints</code> is used.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GroupGraph(GraphByWalks([1,2]),Group([(1,2,3,4,5),(2,5)(3,4)]));</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] 
 ] ) )
</pre></div>

<p><a id="X81DA524381DA5243" name="X81DA524381DA5243"></a></p>

<h4>B.8 <span class="Heading">H</span></h4>

<p><a id="X82276E097B77591E" name="X82276E097B77591E"></a></p>

<h5>B.8-1 HararyToMcKay</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HararyToMcKay</code>( <var class="Arg">Spec</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; McKayToHarary</code>( <var class="Arg">index</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the McKay's <var class="Arg">index</var> of a Harary's graph specification <var class="Arg">Spec</var> and vice versa. Frank Harary published in his book <a href="chapBib.html#biBHar69">[10]</a>, a list of all 208 simple graphs of order up to 6 (up to isomorphism). Each of them had a label (which we call <var class="Arg">Harary's graph specification</var>) of the form <code class="code">[ <var class="Arg">n</var>, <var class="Arg">m</var>, <var class="Arg">s</var> ]</code> where <var class="Arg">n</var> is the number of vertices, <var class="Arg">m</var> is the number of edges, and <var class="Arg">s</var> is a consecutive integer which uniquely identifies the graph from the others with the same <var class="Arg">n</var> and <var class="Arg">m</var>. On the other hand, Brendan McKay published data sets containing a list of all graphs of order up to 10 (also up to isomorphism), here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html">https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html</a></span></p>

<p>Each graph in these data sets appears in some specific position (which we call <em>McKay's index</em>). We found it convenient to have an automated way to convert from Harary's graph specifications to McKay's indexes and vice versa.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([1,0,1]); </span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([1,0,2]);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([5,5,2]);</span>
31
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([5,5,3]);</span>
34
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([5,5,5]);</span>
30
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([5,5,6]);</span>
45
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([5,5,7]); </span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([6,15,1]);</span>
208
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HararyToMcKay([6,15,2]);</span>
fail
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..208],McKayToHarary);</span>
[ [ 1, 0, 1 ], [ 2, 0, 1 ], [ 2, 1, 1 ], [ 3, 0, 1 ], [ 3, 1, 1 ], 
  [ 3, 2, 1 ], [ 3, 3, 1 ], [ 4, 0, 1 ], [ 4, 1, 1 ], [ 4, 2, 1 ], 
  [ 4, 3, 3 ], [ 4, 2, 2 ], [ 4, 3, 1 ], [ 4, 3, 2 ], [ 4, 4, 1 ], 

               --- many more lines here ---   

  [ 6, 10, 10 ], [ 6, 10, 7 ], [ 6, 11, 3 ], [ 6, 12, 1 ], [ 6, 13, 1 ], 
  [ 6, 11, 7 ], [ 6, 11, 9 ], [ 6, 11, 8 ], [ 6, 12, 4 ], [ 6, 12, 5 ], 
  [ 6, 13, 2 ], [ 6, 14, 1 ], [ 6, 15, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">McKayToHarary(209);</span>
fail
</pre></div>

<p><a id="X7FA941E678EAA379" name="X7FA941E678EAA379"></a></p>

<h5>B.8-2 HouseGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HouseGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A 4-cycle and a triangle glued by an edge.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HouseGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
6, Adjacencies := [ [ 2, 4, 5 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], 
  [ 1, 4 ] ] ) )
</pre></div>

<p><a id="X86AA214A86AA214A" name="X86AA214A86AA214A"></a></p>

<h4>B.9 <span class="Heading">I</span></h4>

<p><a id="X83E0EF8F7CCD6979" name="X83E0EF8F7CCD6979"></a></p>

<h5>B.9-1 Icosahedron</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Icosahedron</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The 1-skeleton of Plato's icosahedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Icosahedron;</span>
Graph( rec( Category := SimpleGraphs, Order := 12, Size := 
30, Adjacencies := [ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 9, 10 ], 
  [ 1, 2, 4, 10, 11 ], [ 1, 3, 5, 7, 11 ], [ 1, 4, 6, 7, 8 ], 
  [ 1, 2, 5, 8, 9 ], [ 4, 5, 8, 11, 12 ], [ 5, 6, 7, 9, 12 ], 
  [ 2, 6, 8, 10, 12 ], [ 2, 3, 9, 11, 12 ], [ 3, 4, 7, 10, 12 ], 
  [ 7, 8, 9, 10, 11 ] ] ) )
</pre></div>

<p><a id="X7DF0F8C079D7D07D" name="X7DF0F8C079D7D07D"></a></p>

<h5>B.9-2 ImportGraph6</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImportGraph6</code>( <var class="Arg">Filename</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of graphs represented in <var class="Arg">Filename</var> which are encoded using Brendan McKay's graph6 format. This operation allows us to read data in databases which use this format. Several such databases can be found here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html">https://cs.anu.edu.au/people/Brendan.McKay/data/graphs.html</a></span>.</p>

<p>The graph6 format is described here:</p>

<p><span class="URL"><a href="https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt">https://cs.anu.edu.au/people/Brendan.McKay/data/formats.txt</a></span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=List([1..5],z-&gt;RandomGraph(5));</span>
[ Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    2, Adjacencies := [ [ 2, 3 ], [ 1 ], [ 1 ], [  ], [  ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    5, Adjacencies := [ [ 4, 5 ], [ 3 ], [ 2, 4, 5 ], [ 1, 3 ], [ 1, 3 ] 
     ] ) ), Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    4, Adjacencies := [ [ 2, 4 ], [ 1, 3, 4 ], [ 2 ], [ 1, 2 ], [  ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    6, Adjacencies := [ [ 3, 5 ], [ 3, 5 ], [ 1, 2, 5 ], [ 5 ], 
      [ 1, 2, 3, 4 ] ] ) ), Graph( rec( Category := SimpleGraphs, Order := 
    5, Size := 6, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 5 ], 
      [ 1 ], [ 1, 3 ] ] ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExportGraph6("test.g6",L,true);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:=ImportGraph6("test.g6");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..5],i-&gt;L[i]=S[i]);</span>
[ true, true, true, true, true ]
</pre></div>

<p>If the list in <var class="Arg">Filename</var> is too big to fit in memory, use <code class="func">ImportGraph6Iterator</code> (<a href="chapB.html#X8688B93F7AEF7BB9"><span class="RefLink">B.9-3</span></a>) instead.</p>

<p>See also <code class="func">Graph6ToGraph</code> (<a href="chapB.html#X7DE40F478257F31A"><span class="RefLink">B.7-5</span></a>), <code class="func">ImportGraph6Iterator</code> (<a href="chapB.html#X8688B93F7AEF7BB9"><span class="RefLink">B.9-3</span></a>).</p>

<p><a id="X8688B93F7AEF7BB9" name="X8688B93F7AEF7BB9"></a></p>

<h5>B.9-3 ImportGraph6Iterator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImportGraph6Iterator</code>( <var class="Arg">Filename</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns an iterator on <var class="Arg">Filename</var> that allows us to read and process the graphs in <var class="Arg">Filename</var> sequentially. The graphs in <var class="Arg">Filename</var>, are supposed to be codified in be Brendan McKay's graph6 format. This operation is specially useful when the list in <var class="Arg">Filename</var> is too big to fit in memory (and hence <code class="func">ImportGraph6</code> (<a href="chapB.html#X7DF0F8C079D7D07D"><span class="RefLink">B.9-2</span></a>) cannot be used).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=List([1..5],z-&gt;RandomGraph(5));</span>
[ Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
   2, Adjacencies := [ [ 2, 3 ], [ 1 ], [ 1 ], [  ], [  ] ] ) ), 
 Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
   5, Adjacencies := [ [ 4, 5 ], [ 3 ], [ 2, 4, 5 ], [ 1, 3 ], [ 1, 3 ] 
    ] ) ), Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
   4, Adjacencies := [ [ 2, 4 ], [ 1, 3, 4 ], [ 2 ], [ 1, 2 ], [  ] ] ) ), 
 Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
   6, Adjacencies := [ [ 3, 5 ], [ 3, 5 ], [ 1, 2, 5 ], [ 5 ], 
     [ 1, 2, 3, 4 ] ] ) ), Graph( rec( Category := SimpleGraphs, Order := 
   5, Size := 6, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 5 ], 
     [ 1 ], [ 1, 3 ] ] ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExportGraph6("test.g6",L,true);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter:=ImportGraph6Iterator("test.g6");</span>
&lt;Iterator for test.g6 at 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=NextIterator(iter);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 2, Adjacencies :=
[ [ 2, 3 ], [ 1 ], [ 1 ], [  ], [  ] ] ) ) 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDoneIterator(iter);iter;</span>
false
&lt;Iterator for test.g6 at 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:=[];S[1]:=g;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for g in iter do Add(S,g); od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(S);List([1..5],i-&gt;L[i]=S[i]);</span>
5
[ true, true, true, true, true ]
</pre></div>

<p>See also <code class="func">Graph6ToGraph</code> (<a href="chapB.html#X7DE40F478257F31A"><span class="RefLink">B.7-5</span></a>), <code class="func">ImportGraph6</code> (<a href="chapB.html#X7DF0F8C079D7D07D"><span class="RefLink">B.9-2</span></a>).</p>

<p><a id="X87BDB89B7AAFE8AD" name="X87BDB89B7AAFE8AD"></a></p>

<h5>B.9-4 in</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; in</code>( <var class="Arg">G</var>, <var class="Arg">Catgy</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if graph <var class="Arg">G</var> belongs to category <var class="Arg">Catgy</var> and <code class="code">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=WheelGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
8, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 5 ], [ 1, 2, 4 ], 
  [ 1, 3, 5 ], [ 1, 2, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g in SimpleGraphs;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g in Graphs;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g in OrientedGraphs;</span>
false
</pre></div>

<p><a id="X7D9F576185C58545" name="X7D9F576185C58545"></a></p>

<h5>B.9-5 InducedSubgraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedSubgraph</code>( <var class="Arg">G</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the subgraph of the graph <var class="Arg">G</var> induced by the vertex set <var class="Arg">V</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(6);          </span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
6, Adjacencies := [ [ 2, 6 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], 
  [ 1, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubgraph(g,[3,4,6]);  </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ], [  ] ] ) )
</pre></div>

<p>The order of the elements in <var class="Arg">V</var> does matter.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubgraph(g,[6,3,4]);  </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
1, Adjacencies := [ [  ], [ 3 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X78318B95813CAA26" name="X78318B95813CAA26"></a></p>

<h5>B.9-6 InNeigh</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeigh</code>( <var class="Arg">G</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of in-neighbors of <var class="Arg">x</var> in <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 5, Size := 
10, Adjacencies := [ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], 
  [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeigh(tt,3);                                     </span>
[ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeigh(tt,3);                                    </span>
[ 4, 5 ]
</pre></div>

<p><a id="X7F43E2F0802FD790" name="X7F43E2F0802FD790"></a></p>

<h5>B.9-7 InteriorVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InteriorVertices</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>When <var class="Arg">G</var> is (an underlying graph of a Whitney triangulation of) a compact surface, it returns the list of vertices in the interior (of the triangulation) of the surface. That is, the list of vertices of <var class="Arg">G</var> that have links isomorphic to a cycle. It returns <code class="code">fail</code> if <var class="Arg">G</var> is not a compact surface.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InteriorVertices(WheelGraph(4,2));</span>
[ 1, 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InteriorVertices(Octahedron);     </span>
[ 1, 2, 3, 4, 5, 6 ]
</pre></div>

<p><a id="X827067C078A10B24" name="X827067C078A10B24"></a></p>

<h5>B.9-8 IntersectionGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IntersectionGraph</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the intersection graph of the family of sets <var class="Arg">L</var>. This graph has a vertex for every set in <var class="Arg">L</var>, and two such vertices are adjacent iff the corresponding sets have non-empty intersection.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IntersectionGraph([[1,2,3],[3,4,5],[5,6,7]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X80FF64FC7E750046" name="X80FF64FC7E750046"></a></p>

<h5>B.9-9 IsBoolean</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsBoolean</code>( <var class="Arg">Obj</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if object <var class="Arg">Obj</var> is <code class="code">true</code> or <code class="code">false</code> and <code class="code">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBoolean( true ); IsBoolean( fail ); IsBoolean ( false );</span>
true
false
true
</pre></div>

<p><a id="X78F70A8B7C72464C" name="X78F70A8B7C72464C"></a></p>

<h5>B.9-10 IsCliqueGated</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCliqueGated</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if <var class="Arg">G</var> is a clique gated graph <a href="chapBib.html#biBHK96">[9]</a>.</p>

<p>This operation reports progress at <code class="code">InfoLevel</code> 1 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a>).</p>

<p><a id="X822B38D686BC1D2D" name="X822B38D686BC1D2D"></a></p>

<h5>B.9-11 IsCliqueHelly</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCliqueHelly</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if the set of (maximal) cliques <var class="Arg">G</var> satisfy the <em>Helly</em> property.</p>

<p>The Helly property is defined as follows:</p>

<p>A non-empty family <span class="SimpleMath">F</span> of non-empty sets satisfies the Helly property if every pairwise intersecting subfamily of <span class="SimpleMath">F</span> has a non-empty total intersection.</p>

<p>Here we use the Dragan-Szwarcfiter characterization <a href="chapBib.html#biBDra89">[5]</a><a href="chapBib.html#biBSzw97">[28]</a> to compute the Helly property.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=SunGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
9, Adjacencies := [ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], 
  [ 2, 3, 5, 6 ], [ 4, 6 ], [ 1, 2, 4, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCliqueHelly(g);</span>
false
</pre></div>

<p><a id="X8563061F83E10A23" name="X8563061F83E10A23"></a></p>

<h5>B.9-12 IsCompactSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCompactSurface</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if every link of <var class="Arg">G</var> is either an <var class="Arg">n</var>-cycle, for <span class="SimpleMath">n≥ 4</span> or an <var class="Arg">m</var>-path, for <span class="SimpleMath">m≥ 2</span>. (not necessarily the same <var class="Arg">n</var>/<var class="Arg">m</var> for all vertices); it returns <code class="code">false</code> otherwise.</p>

<p>This notion correspond to Whitney triangulations of compact surfaces <a href="chapBib.html#biBLNP02">[14]</a> in which the (maximal) cliques of the graph are exactly the triangles of the triangulation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCompactSurface(Icosahedron);                             </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCompactSurface(RemoveVertices(Icosahedron,[1]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCompactSurface(WheelGraph(4,2));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCompactSurface(Tetrahedron);    </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCompactSurface(CompleteGraph(2));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCompactSurface(CompleteGraph(3));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCompactSurface(CompleteGraph(4));</span>
false
</pre></div>

<p>Topologically, the difference between a surface and a compact surface is that the points of a surface always have a open neighborhood homeomorphic to an open disk, whereas a compact surface may also contain points with open neighborhoods homeomorphic to a closed half-plane.</p>

<p><a id="X7D689F21828A4278" name="X7D689F21828A4278"></a></p>

<h5>B.9-13 IsComplete</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsComplete</code>( <var class="Arg">G</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if <var class="Arg">L</var> induces a complete subgraph of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsComplete(DiamondGraph,[1,2,3]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsComplete(DiamondGraph,[1,2,4]);</span>
false
</pre></div>

<p><a id="X7BA6EF9F80968CD8" name="X7BA6EF9F80968CD8"></a></p>

<h5>B.9-14 IsCompleteGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCompleteGraph</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if graph <var class="Arg">G</var> is a complete graph, <code class="code">false</code> otherwise. In a complete graph every pair of vertices is an edge.</p>

<p><a id="X7D03ACD07C167E0F" name="X7D03ACD07C167E0F"></a></p>

<h5>B.9-15 IsDiamondFree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDiamondFree</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if <var class="Arg">G</var> is free from induced diamonds (see <code class="func">DiamondGraph</code> (<a href="chapB.html#X84CE76487939DD04"><span class="RefLink">B.4-5</span></a>)); <code class="code">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDiamondFree(Cube);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDiamondFree(Octahedron);</span>
false
</pre></div>

<p><a id="X7F50265D789C602C" name="X7F50265D789C602C"></a></p>

<h5>B.9-16 IsEdge</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsEdge</code>( <var class="Arg">G</var>, <var class="Arg">x</var>, <var class="Arg">y</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsEdge</code>( <var class="Arg">G</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if <code class="code">e:=[<var class="Arg">x</var>,<var class="Arg">y</var>]</code> is an edge of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEdge(PathGraph(3),1,2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEdge(PathGraph(3),[1,2]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEdge(PathGraph(3),1,3);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEdge(PathGraph(3),[1,3]);</span>
false
</pre></div>

<p>The first form, <code class="code">IsEdge(<var class="Arg">G</var>, <var class="Arg">x</var>, <var class="Arg">y</var>)</code>, is a bit faster and hence more suitable for use in algorithms which make extensive use of this operation. On the other hand, the first form does no error checking at all, and hence, it may produce an error where the second form returns false (for instance when <var class="Arg">x</var> is not a vertex of <var class="Arg">G</var>). The second form is therefore a bit slower, but more robust.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEdge(PathGraph(3),[7,3]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEdge(PathGraph(3),7,3);  </span>
Error, List Element: &lt;list&gt;[7] must have an assigned value
</pre></div>

<p><a id="X79CBEA7386509498" name="X79CBEA7386509498"></a></p>

<h5>B.9-17 IsIsomorphicGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIsomorphicGraph</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> when <var class="Arg">G</var> is isomorphic to <var class="Arg">H</var> and <code class="code">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PowerGraph(CycleGraph(6),2);;h:=Octahedron;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicGraph(g,h);</span>
true
</pre></div>

<p><a id="X8219D43086F60B2E" name="X8219D43086F60B2E"></a></p>

<h5>B.9-18 IsListOfPositiveIntegers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsListOfPositiveIntegers</code>( <var class="Arg">Obj</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if object <var class="Arg">Obj</var> is a list of positive integers and <code class="code">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsListOfPositiveIntegers( [1..7] ); </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsListOfPositiveIntegers( [2, 5, 8, 1, 9] ); </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsListOfPositiveIntegers( [ ] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsListOfPositiveIntegers( [0, 2, 3] );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsListOfPositiveIntegers( [7, 3, fail] );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsListOfPositiveIntegers(true);</span>
false
</pre></div>

<p><a id="X782871638792F4F5" name="X782871638792F4F5"></a></p>

<h5>B.9-19 IsLocallyConstant</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLocallyConstant</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if all the links of <var class="Arg">G</var> are isomorphic to each other; <code class="code">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyConstant(PathGraph(2));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyConstant(PathGraph(3));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyConstant(CompleteGraph(3));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyConstant(CycleGraph(4));   </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyConstant(Icosahedron);  </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyConstant(TorusGraph(5,4));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyConstant(WheelGraph(4,2));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyConstant(SnubDisphenoid); </span>
false
</pre></div>

<p><a id="X7ACED06884FBC782" name="X7ACED06884FBC782"></a></p>

<h5>B.9-20 IsLocallyH</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLocallyH</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if all the links of <var class="Arg">G</var> are isomorphic to <var class="Arg">H</var>; <code class="code">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyH(Octahedron,CycleGraph(4));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyH(Octahedron,CycleGraph(5));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyH(Icosahedron,CycleGraph(5));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLocallyH(TorusGraph(4,4),CycleGraph(6));</span>
true
</pre></div>

<p><a id="X7F9F4622817E9AFB" name="X7F9F4622817E9AFB"></a></p>

<h5>B.9-21 IsLoopless</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLoopless</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if the graph <var class="Arg">G</var> have no loops; <code class="code">false</code> otherwise. Loops are edges from a vertex to itself.</p>

<p><a id="X80F38E797C303471" name="X80F38E797C303471"></a></p>

<h5>B.9-22 IsoMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsoMorphism</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns one isomorphism from <var class="Arg">G</var> to <var class="Arg">H</var> or <code class="code">fail</code> if none exists. If <var class="Arg">G</var> has <code class="code">n</code> vertices, an isomorphisms <span class="SimpleMath">f : <var class="Arg">G</var>→ <var class="Arg">H</var></span> is represented as the list <code class="code"><var class="Arg">F</var>=[f(1), f(2), ..., f(n)]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=IsoMorphism(g,h);</span>
[ 1, 3, 2, 4 ]
</pre></div>

<p>See <code class="func">NextIsoMorphism</code> (<a href="chapB.html#X7E3E7CEC812067E6"><span class="RefLink">B.14-1</span></a>).</p>

<p><a id="X7D702EA087C1C5EF" name="X7D702EA087C1C5EF"></a></p>

<h5>B.9-23 IsoMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsoMorphisms</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of all isomorphism from <var class="Arg">G</var> to <var class="Arg">H</var>. If <var class="Arg">G</var> has <code class="code">n</code> vertices, an isomorphisms <span class="SimpleMath">f:<var class="Arg">G</var>→ <var class="Arg">H</var></span> is represented as the list <code class="code"><var class="Arg">F</var>=[f(1), f(2), ..., f(n)]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsoMorphisms(g,h);</span>
[ [ 1, 3, 2, 4 ], [ 1, 4, 2, 3 ], [ 2, 3, 1, 4 ], [ 2, 4, 1, 3 ], 
  [ 3, 1, 4, 2 ], [ 3, 2, 4, 1 ], [ 4, 1, 3, 2 ], [ 4, 2, 3, 1 ] ]
</pre></div>

<p><a id="X8278D52F856A179D" name="X8278D52F856A179D"></a></p>

<h5>B.9-24 IsOriented</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsOriented</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if the graph <var class="Arg">G</var> is an oriented graph, <code class="code">false</code> otherwise. Regardless of the categories that <var class="Arg">G</var> belongs to, <var class="Arg">G</var> is oriented if whenever <code class="code">[x,y]</code> is an edge of <var class="Arg">G</var>, <code class="code">[y,x]</code> is not.</p>

<p><a id="X7D8E63A7824037CC" name="X7D8E63A7824037CC"></a></p>

<h5>B.9-25 IsSimple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSimple</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if the graph <var class="Arg">G</var> is a simple graph, <code class="code">false</code> otherwise. Regardless of the categories that <var class="Arg">G</var> belongs to, <var class="Arg">G</var> is simple if and only if <var class="Arg">G</var> is undirected and loopless.</p>

<p><a id="X8393259C7C8C4B73" name="X8393259C7C8C4B73"></a></p>

<h5>B.9-26 IsSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSurface</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if every link of <var class="Arg">G</var> is an <var class="Arg">n</var>-cycle, for <span class="SimpleMath">n≥ 4</span> (not necessarily the same <var class="Arg">n</var> for all vertices); <code class="code">false</code> otherwise.</p>

<p>This notion correspond to Whitney triangulations of (closed) surfaces <a href="chapBib.html#biBLNP02">[14]</a> in which the (maximal) cliques of the graph are exactly the triangles of the triangulation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSurface(SnubDisphenoid);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSurface(Icosahedron);   </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSurface(RemoveVertices(Icosahedron,[1]));       </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSurface(TorusGraph(4,5));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSurface(WheelGraph(4,2));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSurface(Tetrahedron);    </span>
false
</pre></div>

<p>Topologically, the difference between a (closed) surface and a compact surface is that the points of a surface always have a open neighborhood homeomorphic to an open disk, whereas a compact surface may also contain points with open neighborhoods homeomorphic to a closed half-plane.</p>

<p><a id="X7DD8D1A185EBE865" name="X7DD8D1A185EBE865"></a></p>

<h5>B.9-27 IsTournament</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTournament</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if <var class="Arg">G</var> is a tournament. A <em>tournament</em> is a graph without loops and such that for every pair of vertices <code class="code">x</code>, <code class="code">y</code>, either <code class="code">[x,y]</code> is an arrow of <var class="Arg">G</var> , or <code class="code">[y,x]</code> is an arrow of <var class="Arg">G</var>, but not both.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 5, Size := 
10, Adjacencies := [ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], 
  [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTournament(tt);                                  </span>
true
</pre></div>

<p><a id="X7CC7E10386094A61" name="X7CC7E10386094A61"></a></p>

<h5>B.9-28 IsTransitiveTournament</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTransitiveTournament</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if <var class="Arg">G</var> is a transitive tournament. A tournament is a <em>transitive tournament</em> if whenever <code class="code">[x,y]</code> and <code class="code">[y,z]</code> are arrows of the tournament, <code class="code">[x,z]</code> is also an arrow of the tournament.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 5, Size := 
10, Adjacencies := [ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], 
  [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTransitiveTournament(tt);</span>
true
</pre></div>

<p><a id="X872108F17D8F264D" name="X872108F17D8F264D"></a></p>

<h5>B.9-29 IsUndirected</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUndirected</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns <code class="code">true</code> if the graph <var class="Arg">G</var> is an undirected graph; <code class="code">false</code> otherwise. Regardless of the categories that <var class="Arg">G</var> belongs to, <var class="Arg">G</var> is undirected if whenever <code class="code">[x,y]</code> is an edge of <var class="Arg">G</var>, <code class="code">[y,x]</code> is also an edge of <var class="Arg">G</var>.</p>

<p><a id="X7F3AB4517F3AB451" name="X7F3AB4517F3AB451"></a></p>

<h4>B.10 <span class="Heading">J</span></h4>

<p><a id="X7A4036667F52738C" name="X7A4036667F52738C"></a></p>

<h5>B.10-1 JohnsonGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JohnsonGraph</code>( <var class="Arg">n</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the <em>Johnson graph</em> <span class="SimpleMath">J(n,r)</span>. The Johnson graph is the graph whose vertices are <var class="Arg">r</var>-subset of the set <span class="SimpleMath">{1, 2, ..., n}</span>, two of them being adjacent iff they intersect in exactly <code class="code"><var class="Arg">r</var>-1</code> elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=JohnsonGraph(4,2);                                            </span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], 
  [ 1, 2, 5, 6 ], [ 1, 3, 4, 6 ], [ 2, 3, 4, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexNames(g);</span>
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
</pre></div>

<p><a id="X7870C5F085DD4D77" name="X7870C5F085DD4D77"></a></p>

<h5>B.10-2 Join</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Join</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the join graph <var class="Arg">G</var> + <var class="Arg">H</var> of <var class="Arg">G</var> and <var class="Arg">H</var> (also known as the Zykov sum); it is the graph obtained from the disjoint union of <var class="Arg">G</var> and <var class="Arg">H</var> by adding every possible edge from every vertex in <var class="Arg">G</var> to every vertex in <var class="Arg">H</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=DiscreteGraph(2);h:=CycleGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
0, Adjacencies := [ [  ], [  ] ] ) )
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Join(g,h);                           </span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 4, 6 ], 
  [ 1, 2, 3, 5 ], [ 1, 2, 4, 6 ], [ 1, 2, 3, 5 ] ] ) )
</pre></div>

<p><a id="X784AC758784AC758" name="X784AC758784AC758"></a></p>

<h4>B.11 <span class="Heading">K</span></h4>

<p><a id="X854EB85A7F08DE43" name="X854EB85A7F08DE43"></a></p>

<h5>B.11-1 KiteGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KiteGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A diamond (see <code class="func">DiamondGraph</code> (<a href="chapB.html#X84CE76487939DD04"><span class="RefLink">B.4-5</span></a>)) with a pendant vertex and maximum degree 3.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KiteGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
6, Adjacencies := [ [ 2 ], [ 1, 3, 4 ], [ 2, 4, 5 ], [ 2, 3, 5 ], 
  [ 3, 4 ] ] ) )
</pre></div>

<p><a id="X81AC8E0281AC8E02" name="X81AC8E0281AC8E02"></a></p>

<h4>B.12 <span class="Heading">L</span></h4>

<p><a id="X7F3242BE87F58573" name="X7F3242BE87F58573"></a></p>

<h5>B.12-1 LineGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LineGraph</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the <em>line graph</em>, <var class="Arg">L(G)</var>, of graph <var class="Arg">G</var>. The line graph is the intersection graph of the edges of <var class="Arg">G</var>, <var class="Arg">i.e.</var> the vertices of <span class="SimpleMath">L(G)</span> are the edges of <var class="Arg">G</var> two of them being adjacent iff they are incident.</p>


<div class="example"><pre> 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Tetrahedron;</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LineGraph(g);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], 
  [ 1, 2, 5, 6 ], [ 1, 3, 4, 6 ], [ 2, 3, 4, 5 ] ] ) )
</pre></div>

<p><a id="X799C11E27D07C337" name="X799C11E27D07C337"></a></p>

<h5>B.12-2 Link</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Link</code>( <var class="Arg">G</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the subgraph of <var class="Arg">G</var> induced by the neighbors of <var class="Arg">x</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Link(SnubDisphenoid,1);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] 
 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Link(SnubDisphenoid,3);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ) )
</pre></div>

<p><a id="X86BF290E79C75374" name="X86BF290E79C75374"></a></p>

<h5>B.12-3 Links</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Links</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the list of subgraphs of <var class="Arg">G</var> induced by the neighbors of each vertex of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Links(SnubDisphenoid); </span>
[ Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], 
      [ 1, 4 ] ] ) ), Graph( rec( Category := SimpleGraphs, Order := 
    5, Size := 5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], 
      [ 3, 5 ], [ 1, 4 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    4, Adjacencies := [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    4, Adjacencies := [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
    5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], 
      [ 1, 4 ] ] ) ), Graph( rec( Category := SimpleGraphs, Order := 
    5, Size := 5, Adjacencies := [ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], 
      [ 3, 5 ], [ 1, 4 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    4, Adjacencies := [ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ] ) ), 
  Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
    4, Adjacencies := [ [ 2, 3 ], [ 1, 4 ], [ 1, 4 ], [ 2, 3 ] ] ) ) ]
</pre></div>

<p><a id="X7BD734CC859CDF53" name="X7BD734CC859CDF53"></a></p>

<h5>B.12-4 LooplessGraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LooplessGraphs</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">LooplessGraphs</code> is a graph category in <strong class="pkg">YAGS</strong>. A graph in this category may contain arrows and edges but no loops. The parent of this category is <code class="code">Graphs</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);</span>
Graph( rec( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=LooplessGraphs);</span>
Graph( rec( Category := LooplessGraphs, Order := 3, Size := 
3, Adjacencies := [ [ 2 ], [ 1 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X86DCFD0B86DCFD0B" name="X86DCFD0B86DCFD0B"></a></p>

<h4>B.13 <span class="Heading">M</span></h4>

<p><a id="X7B28B2D07DA68CB0" name="X7B28B2D07DA68CB0"></a></p>

<h5>B.13-1 MaxDegree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaxDegree</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the maximum degree of a vertex in the graph <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=GemGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
7, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], 
  [ 1, 3, 5 ], [ 1, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaxDegree(g);</span>
4
</pre></div>

<p><a id="X865609F480A1A9EC" name="X865609F480A1A9EC"></a></p>

<h5>B.13-2 MinDegree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinDegree</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the minimum degree of a vertex in the graph <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=GemGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
7, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], 
  [ 1, 3, 5 ], [ 1, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinDegree(g);</span>
2
</pre></div>

<p><a id="X7F4C68107F4C6810" name="X7F4C68107F4C6810"></a></p>

<h4>B.14 <span class="Heading">N</span></h4>

<p><a id="X7E3E7CEC812067E6" name="X7E3E7CEC812067E6"></a></p>

<h5>B.14-1 NextIsoMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NextIsoMorphism</code>( <var class="Arg">G</var>, <var class="Arg">H</var>, <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the next isomorphism (after <var class="Arg">F</var>) from <var class="Arg">G</var> to <var class="Arg">H</var> in the lexicographic order; returns <code class="code">fail</code> if there are no more isomorphisms. If <var class="Arg">G</var> has <code class="code">n</code> vertices, an isomorphisms <span class="SimpleMath">f : <var class="Arg">G</var>→ <var class="Arg">H</var></span> is represented as the list <code class="code"><var class="Arg">F</var>=[f(1), f(2), ..., f(n)]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=IsoMorphism(g,h);</span>
[ 1, 3, 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIsoMorphism(g,h,f);</span>
[ 1, 4, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIsoMorphism(g,h,f);</span>
[ 2, 3, 1, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIsoMorphism(g,h,f);</span>
[ 2, 4, 1, 3 ]
</pre></div>

<p><a id="X82361F6E8718C1CA" name="X82361F6E8718C1CA"></a></p>

<h5>B.14-2 NextPropertyMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NextPropertyMorphism</code>( <var class="Arg">G</var>, <var class="Arg">H</var>, <var class="Arg">F</var>, <var class="Arg">PropList</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the next morphism (in lexicographic order) from <var class="Arg">G</var> to <var class="Arg">H</var> satisfying the list of properties <var class="Arg">PropList</var> starting with (possibly incomplete) morphism <var class="Arg">F</var>. The morphism found will be returned <em>and</em> stored in <var class="Arg">F</var> in order to use it as the next starting point, in case <code class="code">NextPropertyMorphism</code> is called again. The operation returns <code class="code">fail</code> if there are no more morphisms of the specified type (but, for technical reasons, <code class="code">F</code> stores the list <code class="code">[fail]</code> instead).</p>

<p>A number of preprogrammed properties are provided by <strong class="pkg">YAGS</strong>, and the user may create additional ones. The properties provided are: <code class="code">CHK_WEAK</code>, <code class="code">CHK_MORPH</code>, <code class="code">CHK_METRIC</code>, <code class="code">CHK_CMPLT</code>, <code class="code">CHK_MONO</code> and <code class="code">CHK_EPI</code>.</p>

<p>If <var class="Arg">G</var> has <code class="code">n</code> vertices and <span class="SimpleMath">f:<var class="Arg">G</var>→ <var class="Arg">H</var></span> is a morphism, it is represented as <code class="code"><var class="Arg">F</var>=[f(1), f(2), ..., f(n)]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=[];; PropList:=[CHK_MORPH,CHK_MONO];;                   </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);                    </span>
[ 1, 3, 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);</span>
[ 1, 4, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);</span>
[ 2, 3, 1, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);</span>
[ 2, 4, 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);</span>
[ 3, 1, 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);</span>
[ 3, 2, 4, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);</span>
[ 4, 1, 3, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);</span>
[ 4, 2, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextPropertyMorphism(g,h,f,PropList);</span>
fail
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 3 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a> and Section <a href="chap6.html#X7F9CE7A87E7B0111"><span class="RefLink">6.4</span></a>).</p>

<p>Extensive information about graph morphisms can be found in Chapter <a href="chap5.html#X7AB9CE86793A0114"><span class="RefLink">5</span></a>.</p>

<p><a id="X83ADC7C07E618A7B" name="X83ADC7C07E618A7B"></a></p>

<h5>B.14-3 NumberOfCliques</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfCliques</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfCliques</code>( <var class="Arg">G</var>, <var class="Arg">maxNumCli</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the number of (maximal) cliques of <var class="Arg">G</var>. In the second form, it stops computing cliques after <var class="Arg">maxNumCli</var> of them have been counted and returns <var class="Arg">maxNumCli</var> in case <var class="Arg">G</var> has <var class="Arg">maxNumCli</var> or more cliques.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfCliques(Icosahedron,15);</span>
15
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfCliques(Icosahedron);</span>
20
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfCliques(Icosahedron,50);</span>
20
</pre></div>

<p>This implementation discards the cliques once counted hence, given enough time, it can compute the number of cliques of <var class="Arg">G</var> even if the set of cliques does not fit in memory. This test may take several minutes to complete:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfCliques(OctahedralGraph(30));</span>
1073741824
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 1 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a>).</p>

<p><a id="X7DB0309583D20862" name="X7DB0309583D20862"></a></p>

<h5>B.14-4 NumberOfConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfConnectedComponents</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the number of connected components of <var class="Arg">G</var>. See <code class="func">ConnectedComponents</code> (<a href="chapB.html#X7945A3B47D94FA49"><span class="RefLink">B.3-17</span></a>).</p>

<p><a id="X783C1B19783C1B19" name="X783C1B19783C1B19"></a></p>

<h4>B.15 <span class="Heading">O</span></h4>

<p><a id="X7B1FCFC979757FED" name="X7B1FCFC979757FED"></a></p>

<h5>B.15-1 OctahedralGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OctahedralGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Return the <var class="Arg">n</var>-dimensional octahedron. This is the complement of <var class="Arg">n</var> copies of <span class="SimpleMath">K_2</span> (an edge). It is also the <var class="Arg">(2n-2)</var>-regular graph on <span class="SimpleMath">2<var class="Arg">n</var></span> vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OctahedralGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], 
  [ 1, 2, 5, 6 ], [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] ) )
</pre></div>

<p><a id="X84BE285087AAC1F7" name="X84BE285087AAC1F7"></a></p>

<h5>B.15-2 Octahedron</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Octahedron</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The 1-skeleton of Plato's octahedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Octahedron;</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
12, Adjacencies := [ [ 3, 4, 5, 6 ], [ 3, 4, 5, 6 ], [ 1, 2, 5, 6 ], 
  [ 1, 2, 5, 6 ], [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ] ] ) )
</pre></div>

<p><a id="X84F59A2687C62763" name="X84F59A2687C62763"></a></p>

<h5>B.15-3 Order</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Order</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the number of vertices, of the graph <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(Icosahedron);</span>
12
</pre></div>

<p><a id="X7B386D5B7E8A9E00" name="X7B386D5B7E8A9E00"></a></p>

<h5>B.15-4 Orientations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Orientations</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of all the oriented graphs that are obtained from <var class="Arg">G</var> by replacing (in every possible way) each edge <code class="code">[x,y]</code> of <var class="Arg">G</var> by one arrow: either <code class="code">[x,y]</code> or <code class="code">[y,x]</code>. In each of these orientations the loops are removed and existing arrows of <var class="Arg">G</var> are left untouched.</p>

<p>Note that this operation will use time and memory which is exponential on the number of edges of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=GraphByWalks([1,1,2,3,1,3,2]:GraphCategory:=Graphs);</span>
Graph( rec( Category := Graphs, Order := 3, Size := 6, Adjacencies := 
[ [ 1, 2, 3 ], [ 3 ], [ 1, 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Orientations(g);</span>
[ Graph( rec( Category := OrientedGraphs, Order := 3, Size := 
    3, Adjacencies := [ [ 2 ], [  ], [ 1, 2 ] ] ) ), 
  Graph( rec( Category := OrientedGraphs, Order := 3, Size := 
    3, Adjacencies := [ [ 2 ], [ 3 ], [ 1 ] ] ) ), 
  Graph( rec( Category := OrientedGraphs, Order := 3, Size := 
    3, Adjacencies := [ [ 2, 3 ], [  ], [ 2 ] ] ) ), 
  Graph( rec( Category := OrientedGraphs, Order := 3, Size := 
    3, Adjacencies := [ [ 2, 3 ], [ 3 ], [  ] ] ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(Orientations(Octahedron));</span>
4096
</pre></div>

<p>Note that <code class="code">Orientations( <var class="Arg">G</var> )</code> returns a list of graphs, each of them in the category <code class="code">OrientedGraphs</code> regardless of the <code class="code">TargetGraphCategory</code>.</p>

<p>This operation reports progress at <code class="code">InfoLevel</code> 3 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a> and Section <a href="chap6.html#X7F9CE7A87E7B0111"><span class="RefLink">6.4</span></a>).</p>

<p><a id="X7A5467E379CD8001" name="X7A5467E379CD8001"></a></p>

<h5>B.15-5 OrientedGraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrientedGraphs</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">OrientedGraphs</code> is a graph category in <strong class="pkg">YAGS</strong>. A graph in this category may contain arrows, but no loops or edges. The parent of this category is <code class="code">LooplessGraphs</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);</span>
Graph( rec( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [  ], [ 2 ] ] ) )
</pre></div>

<p><a id="X7997AFF078E0909F" name="X7997AFF078E0909F"></a></p>

<h5>B.15-6 OutNeigh</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeigh</code>( <var class="Arg">G</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of out-neighbors of <var class="Arg">x</var> in <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tt:=CompleteGraph(5:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 5, Size := 
10, Adjacencies := [ [ 2, 3, 4, 5 ], [ 3, 4, 5 ], [ 4, 5 ], [ 5 ], 
  [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeigh(tt,3);                                     </span>
[ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeigh(tt,3);                                    </span>
[ 4, 5 ]
</pre></div>

<p><a id="X80EC9BC680EC9BC6" name="X80EC9BC680EC9BC6"></a></p>

<h4>B.16 <span class="Heading">P</span></h4>

<p><a id="X7D97312484370E54" name="X7D97312484370E54"></a></p>

<h5>B.16-1 PaleyTournament</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PaleyTournament</code>( <var class="Arg">prime</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the <em>Paley tournament</em> associated with prime number <var class="Arg">prime</var>. The <var class="Arg">prime</var> must be congruent to 3 mod 4. The Paley tournament is the oriented circulant whose <var class="Arg">jumps</var> are all the squares of the ring <span class="SimpleMath">ℤ_p</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Filtered([1..30],x -&gt; 0=((x-3) mod 4) and IsPrime(x));</span>
[ 3, 7, 11, 19, 23 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PaleyTournament(3);PaleyTournament(7);PaleyTournament(11);</span>
Graph( rec( Category := OrientedGraphs, Order := 3, Size := 
3, Adjacencies := [ [ 2 ], [ 3 ], [ 1 ] ] ) )
Graph( rec( Category := OrientedGraphs, Order := 7, Size := 
21, Adjacencies := [ [ 2, 3, 5 ], [ 3, 4, 6 ], [ 4, 5, 7 ], 
  [ 1, 5, 6 ], [ 2, 6, 7 ], [ 1, 3, 7 ], [ 1, 2, 4 ] ] ) )
Graph( rec( Category := OrientedGraphs, Order := 11, Size := 
55, Adjacencies := [ [ 2, 4, 5, 6, 10 ], [ 3, 5, 6, 7, 11 ], 
  [ 1, 4, 6, 7, 8 ], [ 2, 5, 7, 8, 9 ], [ 3, 6, 8, 9, 10 ], 
  [ 4, 7, 9, 10, 11 ], [ 1, 5, 8, 10, 11 ], [ 1, 2, 6, 9, 11 ], 
  [ 1, 2, 3, 7, 10 ], [ 2, 3, 4, 8, 11 ], [ 1, 3, 4, 5, 9 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PaleyTournament(5);                                       </span>
fail
</pre></div>

<p>Note that <code class="code">PaleyTournament( <var class="Arg">prime</var> )</code> returns a graph in the category <code class="code">OrientedGraphs</code> regardless of the <code class="code">TargetGraphCategory</code>.</p>

<p><a id="X8476F4887F0992F4" name="X8476F4887F0992F4"></a></p>

<h5>B.16-2 ParachuteGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ParachuteGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The complement of a <code class="code">ParapluieGraph</code>; The suspension of a 4-path with a pendant vertex attached to the south pole.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParachuteGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 7, Size := 
12, Adjacencies := [ [ 2 ], [ 1, 3, 4, 5, 6 ], [ 2, 4, 7 ], 
  [ 2, 3, 5, 7 ], [ 2, 4, 6, 7 ], [ 2, 5, 7 ], [ 3, 4, 5, 6 ] ] ) )
</pre></div>

<p><a id="X7D013DE67ABF6A4F" name="X7D013DE67ABF6A4F"></a></p>

<h5>B.16-3 ParapluieGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ParapluieGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A 3-fan graph with a 3-path attached to the universal vertex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParapluieGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 7, Size := 
9, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4, 5, 6, 7 ], [ 3, 5 ], 
  [ 3, 4, 6 ], [ 3, 5, 7 ], [ 3, 6 ] ] ) )
</pre></div>

<p><a id="X7C3B877A84E18B53" name="X7C3B877A84E18B53"></a></p>

<h5>B.16-4 ParedGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ParedGraph</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the pared graph of <var class="Arg">G</var>. This is the induced subgraph obtained from <var class="Arg">G</var> by removing its dominated vertices. When there are twin vertices (mutually dominated vertices), exactly one of them survives the paring in each equivalent class of mutually dominated vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=PathGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParedGraph(g1);  </span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:=PathGraph(2);</span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParedGraph(g2);  </span>
Graph( rec( Category := SimpleGraphs, Order := 1, Size := 
0, Adjacencies := [ [  ] ] ) )
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 1 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a>).</p>

<p><a id="X815055168405B7F0" name="X815055168405B7F0"></a></p>

<h5>B.16-5 PathGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PathGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the path graph on <var class="Arg">n</var> vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PathGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] ) )
</pre></div>

<p><a id="X7E2AACE87CE0B493" name="X7E2AACE87CE0B493"></a></p>

<h5>B.16-6 PawGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PawGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The graph on 4 vertices, 4 edges and maximum degree 3: A triangle with a pendant vertex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PawGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2 ], [ 1, 3, 4 ], [ 2, 4 ], [ 2, 3 ] ] ) )
</pre></div>

<p><a id="X823F43217A6C375D" name="X823F43217A6C375D"></a></p>

<h5>B.16-7 PetersenGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PetersenGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The 3-regular graph on 10 vertices having girth 5.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PetersenGraph;  </span>
Graph( rec( Category := SimpleGraphs, Order := 10, Size := 
15, Adjacencies := [ [ 2, 5, 6 ], [ 1, 3, 7 ], [ 2, 4, 8 ], 
  [ 3, 5, 9 ], [ 1, 4, 10 ], [ 1, 8, 9 ], [ 2, 9, 10 ], [ 3, 6, 10 ], 
  [ 4, 6, 7 ], [ 5, 7, 8 ] ] ) )
</pre></div>

<p><a id="X7961543D839F0387" name="X7961543D839F0387"></a></p>

<h5>B.16-8 PowerGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PowerGraph</code>( <var class="Arg">G</var>, <var class="Arg">exp</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the <code class="func">DistanceGraph</code> (<a href="chapB.html#X7C8F3D3385BF41DA"><span class="RefLink">B.4-10</span></a>) of <var class="Arg">G</var> using <code class="code">[0, 1, ..., <var class="Arg">exp</var>]</code> as the list of distances. Note that the distance <code class="code">0</code> in the list produces loops in the new graph only when the <code class="code">TargetGraphCategory</code> admits loops.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerGraph(g,1);                      </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerGraph(g,1:GraphCategory:=Graphs);</span>
Graph( rec( Category := Graphs, Order := 5, Size := 
13, Adjacencies := [ [ 1, 2 ], [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4, 5 ], 
  [ 4, 5 ] ] ) )
</pre></div>

<p><a id="X7C5862667E11AFD8" name="X7C5862667E11AFD8"></a></p>

<h5>B.16-9 PropertyMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PropertyMorphism</code>( <var class="Arg">G</var>, <var class="Arg">H</var>, <var class="Arg">PropList</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the first morphism (in lexicographic order) from <var class="Arg">G</var> to <var class="Arg">H</var> satisfying the list of properties <var class="Arg">PropList</var>.</p>

<p>A number of preprogrammed properties are provided by <strong class="pkg">YAGS</strong>, and the user may create additional ones. The properties provided are: <code class="code">CHK_WEAK</code>, <code class="code">CHK_MORPH</code>, <code class="code">CHK_METRIC</code>, <code class="code">CHK_CMPLT</code>, <code class="code">CHK_MONO</code> and <code class="code">CHK_EPI</code>.</p>

<p>If <var class="Arg">G</var> has <code class="code">n</code> vertices and <span class="SimpleMath">f:<var class="Arg">G</var>→ <var class="Arg">H</var></span> is a morphism, it is represented as <code class="code"><var class="Arg">F</var>=[f(1), f(2), ..., f(n)]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PropList:=[CHK_MORPH];;                            </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PropertyMorphism(g,h,PropList);                          </span>
[ 1, 3, 1, 3 ]
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 3 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a> and Section <a href="chap6.html#X7F9CE7A87E7B0111"><span class="RefLink">6.4</span></a>).</p>

<p>Extensive information about graph morphisms can be found in Chapter <a href="chap5.html#X7AB9CE86793A0114"><span class="RefLink">5</span></a>.</p>

<p><a id="X7F37CF7686868B0C" name="X7F37CF7686868B0C"></a></p>

<h5>B.16-10 PropertyMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PropertyMorphisms</code>( <var class="Arg">G</var>, <var class="Arg">H</var>, <var class="Arg">PropList</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns all morphisms from <var class="Arg">G</var> to <var class="Arg">H</var> satisfying the list of properties <var class="Arg">PropList</var>.</p>

<p>A number of preprogrammed properties are provided by <strong class="pkg">YAGS</strong>, and the user may create additional ones. The properties provided are: <code class="code">CHK_WEAK</code>, <code class="code">CHK_MORPH</code>, <code class="code">CHK_METRIC</code>, <code class="code">CHK_CMPLT</code>, <code class="code">CHK_MONO</code> and <code class="code">CHK_EPI</code>.</p>

<p>If <var class="Arg">G</var> has <code class="code">n</code> vertices and <span class="SimpleMath">f:<var class="Arg">G</var>→ <var class="Arg">H</var></span> is a morphism, it is represented as <code class="code"><var class="Arg">F</var>=[f(1), f(2), ..., f(n)]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;h:=CompleteBipartiteGraph(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PropList:=[CHK_WEAK,CHK_MONO];;                    </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PropertyMorphisms(g,h,PropList);</span>
[ [ 1, 3, 2, 4 ], [ 1, 4, 2, 3 ], [ 2, 3, 1, 4 ], [ 2, 4, 1, 3 ], 
  [ 3, 1, 4, 2 ], [ 3, 2, 4, 1 ], [ 4, 1, 3, 2 ], [ 4, 2, 3, 1 ] ]
</pre></div>

<p>This operation reports progress at <code class="code">InfoLevel</code> 3 (see <a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a> and Section <a href="chap6.html#X7F9CE7A87E7B0111"><span class="RefLink">6.4</span></a>).</p>

<p>Extensive information about graph morphisms can be found in Chapter <a href="chap5.html#X7AB9CE86793A0114"><span class="RefLink">5</span></a>.</p>

<p><a id="X879CE8CF879CE8CF" name="X879CE8CF879CE8CF"></a></p>

<h4>B.17 <span class="Heading">Q</span></h4>

<p><a id="X84213A807DDB5EAF" name="X84213A807DDB5EAF"></a></p>

<h5>B.17-1 QtfyIsSimple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QtfyIsSimple</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For internal use. Returns a non-negative integer indicating how far is the graph <var class="Arg">G</var> from being a simple graph. The return value of 0 means that the graph is simple.</p>

<p><a id="X7ED131997AF10A25" name="X7ED131997AF10A25"></a></p>

<h5>B.17-2 QuadraticRingGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuadraticRingGraph</code>( <var class="Arg">Rng</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the graph G whose vertices are the elements of <var class="Arg">Rng</var> such that <code class="code">x</code> is adjacent to <code class="code">y</code> iff <code class="code">x</code>+<code class="code">z</code><span class="SimpleMath">^2=</span><code class="code">y</code> for some <code class="code">z</code> in <var class="Arg">Rng</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuadraticRingGraph(ZmodnZ(8));</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
12, Adjacencies := [ [ 2, 5, 8 ], [ 1, 3, 6 ], [ 2, 4, 7 ], 
  [ 3, 5, 8 ], [ 1, 4, 6 ], [ 2, 5, 7 ], [ 3, 6, 8 ], [ 1, 4, 7 ] 
 ] ) )
</pre></div>

<p><a id="X783CA3E384E13157" name="X783CA3E384E13157"></a></p>

<h5>B.17-3 QuotientGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuotientGraph</code>( <var class="Arg">G</var>, <var class="Arg">Part</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuotientGraph</code>( <var class="Arg">G</var>, <var class="Arg">L1</var>, <var class="Arg">L2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the quotient graph of graph <var class="Arg">G</var> given a vertex partition <var class="Arg">Part</var>, by identifying any two vertices in the same part. The vertices of the quotient graph are the parts in the partition <var class="Arg">Part</var> two of them being adjacent iff any vertex in one part is adjacent to any vertex in the other part. Singletons may be omitted in <var class="Arg">Part</var>.</p>


<div class="example"><pre> 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(8);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuotientGraph(g,[[1,5,8],[2],[3],[4],[6],[7]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
7, Adjacencies := [ [ 2, 4, 5, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], 
  [ 1, 6 ], [ 1, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuotientGraph(g,[[1,5,8]]);  </span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
7, Adjacencies := [ [ 2, 4, 5, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], 
  [ 1, 6 ], [ 1, 5 ] ] ) )
</pre></div>

<p>In its second form, <code class="code">QuotientGraph</code> identifies each vertex in list <var class="Arg">L1</var>, with the corresponding vertex in list <var class="Arg">L2</var>. <var class="Arg">L1</var> and <var class="Arg">L2</var> must have the same length, but any or both of them may have repetitions.</p>


<div class="example"><pre> 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(8);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuotientGraph(g,[[1,7],[4,8]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
7, Adjacencies := [ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], 
  [ 4, 6 ], [ 1, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuotientGraph(g,[1,4],[7,8]);  </span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
7, Adjacencies := [ [ 2, 4, 6 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3, 5 ], 
  [ 4, 6 ], [ 1, 5 ] ] ) )
</pre></div>

<p><a id="X7E0C7DD47E0C7DD4" name="X7E0C7DD47E0C7DD4"></a></p>

<h4>B.18 <span class="Heading">R</span></h4>

<p><a id="X7BA7762D847502C7" name="X7BA7762D847502C7"></a></p>

<h5>B.18-1 Radius</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Radius</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the minimal eccentricity among the vertices of the graph <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Radius(PathGraph(5)); </span>
2
</pre></div>

<p><a id="X84C9FC4078146520" name="X84C9FC4078146520"></a></p>

<h5>B.18-2 RandomCirculant</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomCirculant</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomCirculant</code>( <var class="Arg">n</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomCirculant</code>( <var class="Arg">n</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a circulant on <var class="Arg">n</var> vertices with its <var class="Arg">jumps</var> selected randomly. In its third form, each possible jump has probability <var class="Arg">p</var> of being selected. In its second form, when <var class="Arg">k</var> is a positive integer, exactly <var class="Arg">k</var> jumps are selected (provided there are at least <var class="Arg">k</var> possible jumps to select from). The first form is equivalent to specifying <var class="Arg">p</var>=1/2. In the ambiguous case when the second parameter is 1, it is interpreted as the value of <var class="Arg">k</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCirculant(11,2);</span>
Graph( rec( Category := SimpleGraphs, Order := 11, Size := 
22, Adjacencies := [ [ 5, 6, 7, 8 ], [ 6, 7, 8, 9 ], [ 7, 8, 9, 10 ], 
  [ 8, 9, 10, 11 ], [ 1, 9, 10, 11 ], [ 1, 2, 10, 11 ], 
  [ 1, 2, 3, 11 ], [ 1, 2, 3, 4 ], [ 2, 3, 4, 5 ], [ 3, 4, 5, 6 ], 
  [ 4, 5, 6, 7 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCirculant(11,2);</span>
Graph( rec( Category := SimpleGraphs, Order := 11, Size := 
22, Adjacencies := [ [ 2, 3, 10, 11 ], [ 1, 3, 4, 11 ], 
  [ 1, 2, 4, 5 ], [ 2, 3, 5, 6 ], [ 3, 4, 6, 7 ], [ 4, 5, 7, 8 ], 
  [ 5, 6, 8, 9 ], [ 6, 7, 9, 10 ], [ 7, 8, 10, 11 ], [ 1, 8, 9, 11 ], 
  [ 1, 2, 9, 10 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCirculant(11,1/2);</span>
Graph( rec( Category := SimpleGraphs, Order := 11, Size := 
44, Adjacencies := 
[ [ 2, 4, 5, 6, 7, 8, 9, 11 ], [ 1, 3, 5, 6, 7, 8, 9, 10 ], 
  [ 2, 4, 6, 7, 8, 9, 10, 11 ], [ 1, 3, 5, 7, 8, 9, 10, 11 ], 
  [ 1, 2, 4, 6, 8, 9, 10, 11 ], [ 1, 2, 3, 5, 7, 9, 10, 11 ], 
  [ 1, 2, 3, 4, 6, 8, 10, 11 ], [ 1, 2, 3, 4, 5, 7, 9, 11 ], 
  [ 1, 2, 3, 4, 5, 6, 8, 10 ], [ 2, 3, 4, 5, 6, 7, 9, 11 ], 
  [ 1, 3, 4, 5, 6, 7, 8, 10 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCirculant(11,1/2);</span>
Graph( rec( Category := SimpleGraphs, Order := 11, Size := 
11, Adjacencies := [ [ 5, 8 ], [ 6, 9 ], [ 7, 10 ], [ 8, 11 ], 
  [ 1, 9 ], [ 2, 10 ], [ 3, 11 ], [ 1, 4 ], [ 2, 5 ], [ 3, 6 ], 
  [ 4, 7 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCirculant(11,1/2);</span>
Graph( rec( Category := SimpleGraphs, Order := 11, Size := 
33, Adjacencies := [ [ 2, 3, 6, 7, 10, 11 ], [ 1, 3, 4, 7, 8, 11 ], 
  [ 1, 2, 4, 5, 8, 9 ], [ 2, 3, 5, 6, 9, 10 ], [ 3, 4, 6, 7, 10, 11 ],
  [ 1, 4, 5, 7, 8, 11 ], [ 1, 2, 5, 6, 8, 9 ], [ 2, 3, 6, 7, 9, 10 ], 
  [ 3, 4, 7, 8, 10, 11 ], [ 1, 4, 5, 8, 9, 11 ], 
  [ 1, 2, 5, 6, 9, 10 ] ] ) )
</pre></div>

<p><a id="X7E3304077D162512" name="X7E3304077D162512"></a></p>

<h5>B.18-3 RandomGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomGraph</code>( <var class="Arg">n</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a random graph of order <var class="Arg">n</var> taking the rational <span class="SimpleMath"><var class="Arg">p</var>∈ [0,1]</span> as the edge probability.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomGraph(5,1/3);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 2, 3, 5 ], [ 1, 5 ], [ 1, 4 ], [ 3 ], [ 1, 2 ] 
 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomGraph(5,2/3);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
7, Adjacencies := [ [ 2, 3 ], [ 1, 3, 4, 5 ], [ 1, 2, 4, 5 ], 
  [ 2, 3 ], [ 2, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomGraph(5,1/2);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 5 ], [ 1, 2 ], 
  [ 3 ] ] ) )
</pre></div>

<p>If <var class="Arg">p</var> is omitted, the edge probability is taken to be 1/2.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomGraph(5);    </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
9, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 5 ], [ 1, 2, 4, 5 ], 
  [ 1, 3, 5 ], [ 1, 2, 3, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
5, Adjacencies := [ [ 2 ], [ 1, 3, 5 ], [ 2, 4 ], [ 3, 5 ], [ 2, 4 ] 
 ] ) )
</pre></div>

<p><a id="X8675AB097F4155AF" name="X8675AB097F4155AF"></a></p>

<h5>B.18-4 RandomPermutation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomPermutation</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a random permutation of the list <code class="code">[1, 2, ... <var class="Arg">n</var>]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomPermutation(12);</span>
(1,8,5,6,7,3,9,10,2,11,4)
</pre></div>

<p><a id="X811BD56879A9FDA4" name="X811BD56879A9FDA4"></a></p>

<h5>B.18-5 RandomSubset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomSubset</code>( <var class="Arg">Set</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomSubset</code>( <var class="Arg">Set</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomSubset</code>( <var class="Arg">Set</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a random subset of the set <var class="Arg">Set</var>. When the positive integer <var class="Arg">k</var> is provided, the returned subset has <var class="Arg">k</var> elements (or <code class="code">fail</code> if <var class="Arg">Set</var> does not have at least <var class="Arg">k</var> elements). When the probability <var class="Arg">p</var> is provided, each element of <var class="Arg">Set</var> has probability <var class="Arg">p</var> of being selected for inclusion in the returned subset. When <var class="Arg">k</var> and <var class="Arg">p</var> are both missing, it is equivalent to specifying <var class="Arg">p</var>=1/2. In the ambiguous case when the second parameter is 1, it is interpreted as the value of <var class="Arg">k</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1..10],5);</span>
[ 1, 6, 7, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1..10],5);</span>
[ 7, 8, 3, 1, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1..10],5);</span>
[ 6, 7, 9, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1..10],5);</span>
[ 3, 4, 2, 8, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1..10],1/2);</span>
[ 2, 4, 5, 6, 7, 8, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1..10],1/2);</span>
[ 5, 6, 7, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1..10],1/2);</span>
[ 3, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1..10],1/2);</span>
[ 4, 5, 6, 7, 8, 10 ]
</pre></div>

<p>Even if this operation is intended to be applied to sets, it does not impose this condition on its operand, and can be applied to lists as well.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1,3,2,2,3,2,1]);</span>
[ 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomSubset([1,3,2,2,3,2,1]);</span>
[ 3, 2, 2, 3, 1 ]
</pre></div>

<p><a id="X815BF58E81DD91B8" name="X815BF58E81DD91B8"></a></p>

<h5>B.18-6 RandomlyPermuted</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomlyPermuted</code>( <var class="Arg">Obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a copy of <var class="Arg">Obj</var> with the order of its elements permuted randomly. Currently, the operation is implemented for lists and graphs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomlyPermuted([1..9]);</span>
[ 8, 7, 1, 9, 4, 2, 5, 6, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomlyPermuted(g);           </span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2, 3 ], [ 1 ], [ 1, 4 ], [ 3 ] ] ) )
</pre></div>

<p><a id="X826C69387F3EB83C" name="X826C69387F3EB83C"></a></p>

<h5>B.18-7 RemoveEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemoveEdges</code>( <var class="Arg">G</var>, <var class="Arg">E</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a new graph created from graph <var class="Arg">G</var> by removing the edges in list <var class="Arg">E</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CompleteGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RemoveEdges(g,[[1,2]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RemoveEdges(g,[[1,2],[3,4]]);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
</pre></div>

<p><a id="X835737627FD4FE21" name="X835737627FD4FE21"></a></p>

<h5>B.18-8 RemoveVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemoveVertices</code>( <var class="Arg">G</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a new graph created from graph <var class="Arg">G</var> by removing the vertices in list <var class="Arg">V</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
4, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RemoveVertices(g,[3]);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
2, Adjacencies := [ [ 2 ], [ 1 ], [ 4 ], [ 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RemoveVertices(g,[1,3]);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
1, Adjacencies := [ [  ], [ 3 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X7B944F3286DE401F" name="X7B944F3286DE401F"></a></p>

<h5>B.18-9 RGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A square with two pendant vertices attached to the same vertex of the square.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
6, Adjacencies := [ [ 2 ], [ 1, 3, 5, 6 ], [ 2, 4 ], [ 3, 5 ], 
  [ 2, 4 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X7DAEE13082F5EA2D" name="X7DAEE13082F5EA2D"></a></p>

<h5>B.18-10 RingGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RingGraph</code>( <var class="Arg">Rng</var>, <var class="Arg">Elms</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the graph G whose vertices are the elements of the ring <var class="Arg">Rng</var> such that <code class="code">x</code> is adjacent to <code class="code">y</code> iff <code class="code">x+r=y</code> for some <code class="code">r </code> in <var class="Arg">Elms</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r:=FiniteField(8);Elements(r); </span>
GF(2^3)
[ 0*Z(2), Z(2)^0, Z(2^3), Z(2^3)^2, Z(2^3)^3, Z(2^3)^4, Z(2^3)^5, 
  Z(2^3)^6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RingGraph(r,[Z(2^3),Z(2^3)^4]);</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
8, Adjacencies := [ [ 3, 6 ], [ 5, 7 ], [ 1, 4 ], [ 3, 6 ], [ 2, 8 ], 
  [ 1, 4 ], [ 2, 8 ], [ 5, 7 ] ] ) )
</pre></div>

<p><a id="X797C0EDD797C0EDD" name="X797C0EDD797C0EDD"></a></p>

<h4>B.19 <span class="Heading">S</span></h4>

<p><a id="X7C0E31767FBBD2F6" name="X7C0E31767FBBD2F6"></a></p>

<h5>B.19-1 SetCoordinates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetCoordinates</code>( <var class="Arg">G</var>, <var class="Arg">Coord</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Sets the coordinates of the vertices of <var class="Arg">G</var>, which are used to draw <var class="Arg">G</var> by <code class="func">Draw</code> (<a href="chapB.html#X7DF9F3AD86602DFC"><span class="RefLink">B.4-16</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CycleGraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(g);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetCoordinates(g,[[-10,-10 ],[-10,20],[20,-10 ], [20,20]]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(g);</span>
[ [ -10, -10 ], [ -10, 20 ], [ 20, -10 ], [ 20, 20 ] ]
</pre></div>

<p><a id="X790BE2F980902645" name="X790BE2F980902645"></a></p>

<h5>B.19-2 SetDefaultGraphCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDefaultGraphCategory</code>( <var class="Arg">Catgy</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Sets the default graph category to <var class="Arg">Catgy</var>. The default graph category is used when constructing new graphs when no other graph category is indicated. New graphs are always forced to comply with the <code class="code">TargetGraphCategory</code>, so loops may be removed, and arrows may replaced by edges or vice versa, depending on the category that the new graph belongs to.</p>

<p>The available graph categories are: <code class="code">SimpleGraphs</code>, <code class="code">OrientedGraphs</code>, <code class="code">UndirectedGraphs</code>, <code class="code">LooplessGraphs</code>, and <code class="code">Graphs</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDefaultGraphCategory(Graphs);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]);</span>
Graph( rec( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDefaultGraphCategory(LooplessGraphs);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]);  </span>
Graph( rec( Category := LooplessGraphs, Order := 3, Size := 
3, Adjacencies := [ [ 2 ], [ 1 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDefaultGraphCategory(UndirectedGraphs);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]);    </span>
Graph( rec( Category := UndirectedGraphs, Order := 3, Size := 
3, Adjacencies := [ [ 1, 2 ], [ 1, 3 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDefaultGraphCategory(OrientedGraphs);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]);  </span>
Graph( rec( Category := OrientedGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [  ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDefaultGraphCategory(SimpleGraphs);    </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X786FE7C97A76D747" name="X786FE7C97A76D747"></a></p>

<h5>B.19-3 SimpleGraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleGraphs</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">SimpleGraphs</code> is a graph category in <strong class="pkg">YAGS</strong>. A graph in this category may contain edges, but no loops or arrows. This category has two parents: <code class="code">LooplessGraphs</code> and <code class="code">UndirectedGraphs</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);</span>
Graph( rec( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=SimpleGraphs);  </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X858ADA3B7A684421" name="X858ADA3B7A684421"></a></p>

<h5>B.19-4 Size</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the number of edges of the graph <var class="Arg">G</var>. Note that the returned value depends not only on the structure of the graph, but also on the category to which it belongs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=CycleGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:=CopyGraph(g1:GraphCategory:=Graphs);</span>
Graph( rec( Category := Graphs, Order := 4, Size := 8, Adjacencies := 
[ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(g1);         </span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(g2);</span>
8
</pre></div>

<p><a id="X8723A75E7C614604" name="X8723A75E7C614604"></a></p>

<h5>B.19-5 SnubDisphenoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SnubDisphenoid</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The 1-skeleton of the 84th Johnson solid.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SnubDisphenoid;</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
18, Adjacencies := [ [ 2, 3, 4, 5, 8 ], [ 1, 3, 6, 7, 8 ], 
  [ 1, 2, 4, 6 ], [ 1, 3, 5, 6 ], [ 1, 4, 6, 7, 8 ], 
  [ 2, 3, 4, 5, 7 ], [ 2, 5, 6, 8 ], [ 1, 2, 5, 7 ] ] ) )
</pre></div>

<p><a id="X7A142732800BA3FB" name="X7A142732800BA3FB"></a></p>

<h5>B.19-6 SpanningForest</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpanningForest</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the a maximal spanning forest of <var class="Arg">G</var>. Since the forest is maximal, it is composed of a spanning tree for each connected component of <var class="Arg">G</var>. In particular, this operation actually returns a spanning tree whenever the graph is connected.</p>

<p><a id="X7F041A81846012EE" name="X7F041A81846012EE"></a></p>

<h5>B.19-7 SpanningForestEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpanningForestEdges</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the edges of a maximal spanning forest of <var class="Arg">G</var>. Since the forest is maximal, it is composed of a spanning tree for each connected component of <var class="Arg">G</var>. In particular, this operation actually returns the edges of a spanning tree whenever the graph is connected.</p>

<p><a id="X85D92DDF7EC14AF0" name="X85D92DDF7EC14AF0"></a></p>

<h5>B.19-8 SpikyGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpikyGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The spiky graph is constructed as follows: Take a complete graph on <var class="Arg">n</var> vertices, <span class="SimpleMath">K_<var class="Arg">n</var></span>, and then, for each the <var class="Arg">n</var> subsets of <span class="SimpleMath">Vertices(K_<var class="Arg">n</var>)</span> of order <var class="Arg">n</var><code class="code">-1</code>, add an additional vertex which is adjacent precisely to this subset of <span class="SimpleMath">Vertices(K_<var class="Arg">n</var>)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpikyGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
9, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], 
  [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ) )
</pre></div>

<p><a id="X7DB6D22E86A5B572" name="X7DB6D22E86A5B572"></a></p>

<h5>B.19-9 SunGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SunGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the <var class="Arg">n</var>-Sun: A complete graph on <var class="Arg">n</var> vertices, <span class="SimpleMath">K_<var class="Arg">n</var></span>, with a corona made with a zigzagging 2<var class="Arg">n</var>-cycle glued to a <var class="Arg">n</var>-cycle of the <span class="SimpleMath">K_<var class="Arg">n</var></span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SunGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
9, Adjacencies := [ [ 2, 6 ], [ 1, 3, 4, 6 ], [ 2, 4 ], 
  [ 2, 3, 5, 6 ], [ 4, 6 ], [ 1, 2, 4, 5 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SunGraph(4);</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
14, Adjacencies := [ [ 2, 8 ], [ 1, 3, 4, 6, 8 ], [ 2, 4 ], 
  [ 2, 3, 5, 6, 8 ], [ 4, 6 ], [ 2, 4, 5, 7, 8 ], [ 6, 8 ], 
  [ 1, 2, 4, 6, 7 ] ] ) )
</pre></div>

<p><a id="X8743540878E206BD" name="X8743540878E206BD"></a></p>

<h5>B.19-10 Suspension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Suspension</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the suspension of graph <var class="Arg">G</var>. The suspension of <var class="Arg">G</var> is the graph obtained from <var class="Arg">G</var> by adding two new vertices which are adjacent to every vertex of <var class="Arg">G</var> but not to each other. The new vertices are the first ones in the new graph.</p>


<div class="example"><pre> 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Suspension(CycleGraph(5));</span>
Graph( rec( Category := SimpleGraphs, Order := 7, Size := 
15, Adjacencies := [ [ 3, 4, 5, 6, 7 ], [ 3, 4, 5, 6, 7 ], [ 1, 2, 4, 7 ], 
  [ 1, 2, 3, 5 ], [ 1, 2, 4, 6 ], [ 1, 2, 5, 7 ], [ 1, 2, 3, 6 ] ] ) )
</pre></div>

<p><a id="X809A4787809A4787" name="X809A4787809A4787"></a></p>

<h4>B.20 <span class="Heading">T</span></h4>

<p><a id="X7F7026FF83934BBC" name="X7F7026FF83934BBC"></a></p>

<h5>B.20-1 TargetGraphCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TargetGraphCategory</code>( [<var class="Arg">G</var>, <var class="Arg">...</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For internal use. Returns the graph category indicated in the <var class="Arg">options stack</var> if any, otherwise if the list of graphs provided is not empty, returns the minimal common graph category for the graphs in the list, else returns the default graph category. The partial order (by inclusion) among graph categories is as follows:</p>


<pre class="normal">

                Graphs
              /        \    
UndirectedGraphs      LooplessGraphs
              \        /          \       
             SimpleGraphs        OrientedGraphs

</pre>

<p>This function is internally called by all graph constructing operations in <strong class="pkg">YAGS</strong> to decide the graph category that the newly constructed graph is going to belong. New graphs are always forced to comply with the <code class="code">TargetGraphCategory</code>, so loops may be removed, and arrows may replaced by edges or vice versa, depending on the category that the new graph belongs to.</p>

<p>The <var class="Arg">options stack</var> is a mechanism provided by <strong class="pkg">GAP</strong> to pass implicit parameters and is used by <code class="code">TargetGraphCategory</code> so that the user may indicate the graph category she/he wants for the new graph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDefaultGraphCategory(SimpleGraphs);             </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=CompleteGraph(2);                              </span>
Graph( rec( Category := SimpleGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [ 1 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:=CompleteGraph(2:GraphCategory:=OrientedGraphs);</span>
Graph( rec( Category := OrientedGraphs, Order := 2, Size := 
1, Adjacencies := [ [ 2 ], [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisjointUnion(g1,g2);</span>
Graph( rec( Category := LooplessGraphs, Order := 4, Size := 
3, Adjacencies := [ [ 2 ], [ 1 ], [ 4 ], [  ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisjointUnion(g1,g2:GraphCategory:=UndirectedGraphs);</span>
Graph( rec( Category := UndirectedGraphs, Order := 4, Size := 
2, Adjacencies := [ [ 2 ], [ 1 ], [ 4 ], [ 3 ] ] ) )
</pre></div>

<p>In the previous examples, <code class="code">TargetGraphCategory</code> was called internally exactly once for each new graph constructed with the following parameters:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TargetGraphCategory();</span>
&lt;Category "SimpleGraphs"&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TargetGraphCategory(:GraphCategory:=OrientedGraphs);</span>
&lt;Category "OrientedGraphs"&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TargetGraphCategory([g1,g2]);                       </span>
&lt;Category "LooplessGraphs"&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TargetGraphCategory([g1,g2]:GraphCategory:=UndirectedGraphs);</span>
&lt;Category "UndirectedGraphs"&gt;
</pre></div>

<p><a id="X7B44DDD485145773" name="X7B44DDD485145773"></a></p>

<h5>B.20-2 Tetrahedron</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Tetrahedron</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The 1-skeleton of Plato's tetrahedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Tetrahedron;</span>
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
6, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], 
  [ 1, 2, 3 ] ] ) )
</pre></div>

<p><a id="X86C7A3E27AF64042" name="X86C7A3E27AF64042"></a></p>

<h5>B.20-3 TimeInSeconds</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TimeInSeconds</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the time in seconds since 1970-01-01 00:00:00 UTC as an integer. This is useful to measure execution time. It can also be used to impose time constraints on the execution of algorithms. Note however that the time reported is the <em>wall time</em>, not necessarily the time spent in the process you intend to measure.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TimeInSeconds();</span>
1415551598
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:=CliqueGraph;;NumCli:=NumberOfCliques;;I:=Icosahedron;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t1:=TimeInSeconds();NumCli(K(K(K(K(I)))));TimeInSeconds()-t1;</span>
1415551608
44644
103
</pre></div>

<p>Currently, this operation does not work on MS Windows.</p>

<p><a id="X803A2BC67C63AA25" name="X803A2BC67C63AA25"></a></p>

<h5>B.20-4 TimesProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TimesProduct</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the times product, <var class="Arg">G</var><span class="SimpleMath">×</span><var class="Arg">H</var>, of two graphs <var class="Arg">G</var> and <var class="Arg">H</var> (also known as the tensor product).</p>

<p>The times product is computed as follows:</p>

<p>For each pair of vertices <span class="SimpleMath">x ∈ <var class="Arg">G</var>, y ∈ <var class="Arg">H</var></span> we create a vertex <span class="SimpleMath">(x,y)</span>. Given two such vertices <span class="SimpleMath">(x,y)</span> and <span class="SimpleMath">(x',y')</span> they are adjacent iff <span class="SimpleMath">x ∼ x'</span> and <span class="SimpleMath">y ∼ y'</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(3);h:=CycleGraph(4);                              </span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
Graph( rec( Category := SimpleGraphs, Order := 4, Size := 
4, Adjacencies := [ [ 2, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gh:=TimesProduct(g,h);         </span>
Graph( rec( Category := SimpleGraphs, Order := 12, Size := 
16, Adjacencies := [ [ 6, 8 ], [ 5, 7 ], [ 6, 8 ], [ 5, 7 ], 
  [ 2, 4, 10, 12 ], [ 1, 3, 9, 11 ], [ 2, 4, 10, 12 ], 
  [ 1, 3, 9, 11 ], [ 6, 8 ], [ 5, 7 ], [ 6, 8 ], [ 5, 7 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexNames(gh);                 </span>
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 2 ], 
  [ 2, 3 ], [ 2, 4 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ] ]
</pre></div>

<p><a id="X87B9CA2A8552F40A" name="X87B9CA2A8552F40A"></a></p>

<h5>B.20-5 TorusGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TorusGraph</code>( <var class="Arg">n</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns (the underlying graph of) a triangulation of the torus on <var class="Arg">nm</var> vertices. This graph is constructed using <span class="SimpleMath">{1,2,..., <var class="Arg">n</var>}×{1,2,..., <var class="Arg">m</var>}</span> as the vertex set; two of them being adjacent if their difference belongs to <span class="SimpleMath">{(1,0),(0,1),(1,1)}</span> module <span class="SimpleMath">ℤ_<var class="Arg">n</var>×ℤ_<var class="Arg">m</var></span>. Hence, in the category of simple graphs, <code class="code">TorusGraph</code> is a 6-regular graph when <span class="SimpleMath"><var class="Arg">n</var>,<var class="Arg">m</var>≥ 3</span>.</p>


<div class="example"><pre>
TorusGraph(4,4);
Graph( Category := SimpleGraphs, Order := 16, Size := 48, Adjacencies := 
[ [ 2, 4, 5, 6, 13, 16 ], [ 1, 3, 6, 7, 13, 14 ], [ 2, 4, 7, 8, 14, 15 ], 
  [ 1, 3, 5, 8, 15, 16 ], [ 1, 4, 6, 8, 9, 10 ], [ 1, 2, 5, 7, 10, 11 ], 
  [ 2, 3, 6, 8, 11, 12 ], [ 3, 4, 5, 7, 9, 12 ], [ 5, 8, 10, 12, 13, 14 ], 
  [ 5, 6, 9, 11, 14, 15 ], [ 6, 7, 10, 12, 15, 16 ], [ 7, 8, 9, 11, 13, 16 ], 
  [ 1, 2, 9, 12, 14, 16 ], [ 2, 3, 9, 10, 13, 15 ], [ 3, 4, 10, 11, 14, 16 ], 
  [ 1, 4, 11, 12, 13, 15 ] ] )
</pre></div>

<p>When <span class="SimpleMath"><var class="Arg">n</var>,<var class="Arg">m</var>≥ 4</span>, <code class="code">TorusGraph( <var class="Arg">n</var>, <var class="Arg">m</var> )</code> is actually a Whitney triangulation: the (maximal) cliques of the graph are exactly the triangles of the triangulation. The clique behavior of these graphs were extensively studied in <a href="chapBib.html#biBLN99">[12]</a>. However, this operation constructs the described graph for all <span class="SimpleMath"><var class="Arg">n</var>,<var class="Arg">m</var> ≥ 1</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TorusGraph(2,4);</span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
20, Adjacencies := [ [ 2, 4, 5, 6, 8 ], [ 1, 3, 5, 6, 7 ], 
  [ 2, 4, 6, 7, 8 ], [ 1, 3, 5, 7, 8 ], [ 1, 2, 4, 6, 8 ], 
  [ 1, 2, 3, 5, 7 ], [ 2, 3, 4, 6, 8 ], [ 1, 3, 4, 5, 7 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TorusGraph(2,3);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
15, Adjacencies := [ [ 2, 3, 4, 5, 6 ], [ 1, 3, 4, 5, 6 ], 
  [ 1, 2, 4, 5, 6 ], [ 1, 2, 3, 5, 6 ], [ 1, 2, 3, 4, 6 ], 
  [ 1, 2, 3, 4, 5 ] ] ) )
</pre></div>

<p>Note that in these cases, <code class="code">TorusGraph( <var class="Arg">n</var>, <var class="Arg">m</var> )</code> is not 6-regular nor a Whitney triangulation.</p>

<p><a id="X7C7EAB207C957EB1" name="X7C7EAB207C957EB1"></a></p>

<h5>B.20-6 TreeGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TreeGraph</code>( <var class="Arg">arity</var>, <var class="Arg">depth</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TreeGraph</code>( <var class="Arg">ArityList</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a tree, a connected cycle-free graph. In its second form, the vertices at depth <code class="code">k</code> (the root vertex has depth 1 here) have <span class="SimpleMath"><var class="Arg">ArityList</var>[</span><code class="code">k</code><span class="SimpleMath">]</span> children. In its first form, all vertices, but the leaves, have <var class="Arg">arity</var> children and the depth of the leaves is <var class="Arg">depth</var><code class="code">+1</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TreeGraph(2,3);                                                  </span>
Graph( rec( Category := SimpleGraphs, Order := 15, Size := 
14, Adjacencies := [ [ 2, 3 ], [ 1, 4, 5 ], [ 1, 6, 7 ], [ 2, 8, 9 ], 
  [ 2, 10, 11 ], [ 3, 12, 13 ], [ 3, 14, 15 ], [ 4 ], [ 4 ], [ 5 ], 
  [ 5 ], [ 6 ], [ 6 ], [ 7 ], [ 7 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TreeGraph([3,2,2]);</span>
Graph( rec( Category := SimpleGraphs, Order := 22, Size := 
21, Adjacencies := [ [ 2, 3, 4 ], [ 1, 5, 6 ], [ 1, 7, 8 ], 
  [ 1, 9, 10 ], [ 2, 11, 12 ], [ 2, 13, 14 ], [ 3, 15, 16 ], 
  [ 3, 17, 18 ], [ 4, 19, 20 ], [ 4, 21, 22 ], [ 5 ], [ 5 ], [ 6 ], 
  [ 6 ], [ 7 ], [ 7 ], [ 8 ], [ 8 ], [ 9 ], [ 9 ], [ 10 ], [ 10 ] 
 ] ) )
</pre></div>

<p><a id="X82C1EADA7E3EE838" name="X82C1EADA7E3EE838"></a></p>

<h5>B.20-7 TrivialGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialGraph</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The one vertex graph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TrivialGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 1, Size := 
0, Adjacencies := [ [  ] ] ) )
</pre></div>

<p><a id="X87EA348E87EA348E" name="X87EA348E87EA348E"></a></p>

<h4>B.21 <span class="Heading">U</span></h4>

<p><a id="X795BE08A79C126FC" name="X795BE08A79C126FC"></a></p>

<h5>B.21-1 UFFind</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UFFind</code>( <var class="Arg">UFS</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For internal use. Implements the <em>find</em> operation on the <em>union-find structure</em>.</p>

<p><a id="X8105AD137ECF5AE4" name="X8105AD137ECF5AE4"></a></p>

<h5>B.21-2 UFUnite</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UFUnite</code>( <var class="Arg">UFS</var>, <var class="Arg">x</var>, <var class="Arg">y</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For internal use. Implements the <em>unite</em> operation on the <em>union-find structure</em>.</p>

<p><a id="X7CC6D5C77C0CCFA3" name="X7CC6D5C77C0CCFA3"></a></p>

<h5>B.21-3 UndirectedGraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UndirectedGraphs</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">UndirectedGraphs</code> is a graph category in <strong class="pkg">YAGS</strong>. A graph in this category may contain edges and loops, but no arrows. The parent of this category is <code class="code">Graphs</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=Graphs);</span>
Graph( rec( Category := Graphs, Order := 3, Size := 4, Adjacencies := 
[ [ 1, 2 ], [ 1 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GraphByWalks([1,1],[1,2],[2,1],[3,2]:GraphCategory:=UndirectedGraphs);</span>
Graph( rec( Category := UndirectedGraphs, Order := 3, Size := 
3, Adjacencies := [ [ 1, 2 ], [ 1, 3 ], [ 2 ] ] ) )
</pre></div>

<p><a id="X7FDA5DD47D181699" name="X7FDA5DD47D181699"></a></p>

<h5>B.21-4 UnitsRingGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnitsRingGraph</code>( <var class="Arg">Rng</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the graph G whose vertices are the elements of <var class="Arg">Rng</var> such that <code class="code">x</code> is adjacent to <code class="code">y</code> iff <code class="code">x+z=y</code> for some unit <code class="code">z</code> of <var class="Arg">Rng</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnitsRingGraph(ZmodnZ(8));    </span>
Graph( rec( Category := SimpleGraphs, Order := 8, Size := 
16, Adjacencies := [ [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ], [ 2, 4, 6, 8 ], 
  [ 1, 3, 5, 7 ], [ 2, 4, 6, 8 ], [ 1, 3, 5, 7 ], [ 2, 4, 6, 8 ], 
  [ 1, 3, 5, 7 ] ] ) )
</pre></div>

<p><a id="X7E7AA1957E7AA195" name="X7E7AA1957E7AA195"></a></p>

<h4>B.22 <span class="Heading">V</span></h4>

<p><a id="X7B5898D98493A41D" name="X7B5898D98493A41D"></a></p>

<h5>B.22-1 VertexDegree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VertexDegree</code>( <var class="Arg">G</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the degree of vertex <var class="Arg">x</var> in Graph <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=PathGraph(3);</span>
Graph( rec( Category := SimpleGraphs, Order := 3, Size := 
2, Adjacencies := [ [ 2 ], [ 1, 3 ], [ 2 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexDegree(g,1);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexDegree(g,2);</span>
2
</pre></div>

<p><a id="X8406A82E7973EC00" name="X8406A82E7973EC00"></a></p>

<h5>B.22-2 VertexDegrees</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VertexDegrees</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list of degrees of the vertices in graph <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=GemGraph;</span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
7, Adjacencies := [ [ 2, 3, 4, 5 ], [ 1, 3 ], [ 1, 2, 4 ], 
  [ 1, 3, 5 ], [ 1, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexDegrees(g);</span>
[ 4, 2, 3, 3, 2 ]
</pre></div>

<p><a id="X86050933823255F1" name="X86050933823255F1"></a></p>

<h5>B.22-3 VertexNames</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VertexNames</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Return the list of names of the vertices of <var class="Arg">G</var>. The vertices of a graph in <strong class="pkg">YAGS</strong> are always <span class="SimpleMath">{1,2, ...,</span><code class="code">Order(<var class="Arg">G</var>)</code><span class="SimpleMath">}</span>, but depending on how the graph was constructed, its vertices may have also some <em>names</em>, that help us identify the origin of the vertices. <strong class="pkg">YAGS</strong> will always try to store meaningful names for the vertices. For example, in the case of the <code class="code">LineGraph</code>, the vertex names of the new graph are the edges of the old graph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=LineGraph(DiamondGraph);          </span>
Graph( rec( Category := SimpleGraphs, Order := 5, Size := 
8, Adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4, 5 ], [ 1, 2, 5 ], 
  [ 1, 2, 5 ], [ 2, 3, 4 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexNames(g);</span>
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Edges(DiamondGraph);</span>
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 3, 4 ] ]
</pre></div>

<p><a id="X79E4BB4F849AC8A1" name="X79E4BB4F849AC8A1"></a></p>

<h5>B.22-4 Vertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Vertices</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the list <code class="code">[1..Order( <var class="Arg">G</var> )]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Vertices(Icosahedron);</span>
[ 1 .. 12 ]
</pre></div>

<p><a id="X790AD29C790AD29C" name="X790AD29C790AD29C"></a></p>

<h4>B.23 <span class="Heading">W</span></h4>

<p><a id="X817EA60D828A765E" name="X817EA60D828A765E"></a></p>

<h5>B.23-1 WheelGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WheelGraph</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WheelGraph</code>( <var class="Arg">n</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>In its first form <code class="code">WheelGraph</code> returns the wheel graph on <var class="Arg">n</var>+1 vertices. This is the cone of a cycle: a central vertex adjacent to all the vertices of an <var class="Arg">n</var>-cycle.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WheelGraph(5);</span>
Graph( rec( Category := SimpleGraphs, Order := 6, Size := 
10, Adjacencies := [ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6 ], [ 1, 2, 4 ], 
  [ 1, 3, 5 ], [ 1, 4, 6 ], [ 1, 2, 5 ] ] ) )
</pre></div>

<p>In its second form, <code class="code">WheelGraph</code> returns returns the wheel graph, but adding <var class="Arg">r</var><code class="code">-1</code> layers, each layer is a new <var class="Arg">n</var>-cycle joined to the previous layer by a zigzagging 2<var class="Arg">n</var>-cycle. This graph is a triangulation of the disk.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WheelGraph(5,2);</span>
Graph( rec( Category := SimpleGraphs, Order := 11, Size := 
25, Adjacencies := [ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 7, 8 ], 
  [ 1, 2, 4, 8, 9 ], [ 1, 3, 5, 9, 10 ], [ 1, 4, 6, 10, 11 ], 
  [ 1, 2, 5, 7, 11 ], [ 2, 6, 8, 11 ], [ 2, 3, 7, 9 ], 
  [ 3, 4, 8, 10 ], [ 4, 5, 9, 11 ], [ 5, 6, 7, 10 ] ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WheelGraph(5,3);</span>
Graph( rec( Category := SimpleGraphs, Order := 16, Size := 
40, Adjacencies := [ [ 2, 3, 4, 5, 6 ], [ 1, 3, 6, 7, 8 ], 
  [ 1, 2, 4, 8, 9 ], [ 1, 3, 5, 9, 10 ], [ 1, 4, 6, 10, 11 ], 
  [ 1, 2, 5, 7, 11 ], [ 2, 6, 8, 11, 12, 13 ], [ 2, 3, 7, 9, 13, 14 ],
  [ 3, 4, 8, 10, 14, 15 ], [ 4, 5, 9, 11, 15, 16 ], 
  [ 5, 6, 7, 10, 12, 16 ], [ 7, 11, 13, 16 ], [ 7, 8, 12, 14 ], 
  [ 8, 9, 13, 15 ], [ 9, 10, 14, 16 ], [ 10, 11, 12, 15 ] ] ) )
</pre></div>

<p><a id="X8771504C8771504C" name="X8771504C8771504C"></a></p>

<h4>B.24 <span class="Heading">Y</span></h4>

<p><a id="X8150D2E37EA1F25D" name="X8150D2E37EA1F25D"></a></p>

<h5>B.24-1 YAGSExec</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YAGSExec</code>( <var class="Arg">ProgName</var>, <var class="Arg">InString</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For internal use. Calls external program <var class="Arg">ProgName</var> located in directory <code class="file">YAGS-DIR/bin/</code> feeding it with <var class="Arg">InString</var> as input and returning the output of the external program as a string. <code class="code">fail</code> is returned if the program could not be located.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">YAGSExec("time","");</span>
"1415551127\n"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">YAGSExec("nauty","l=0$=1dacn=5 g1,2,3. xbzq");</span>
"(4,5)\n(2,3)\n[2,3,4,5,1]\n[\"cb0c\",\"484f264\",\"b0e19f1\"]\n"
</pre></div>

<p>This operation have not been tested on MS Windows.</p>

<p><a id="X865EB51A79C27268" name="X865EB51A79C27268"></a></p>

<h5>B.24-2 YAGSInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YAGSInfo</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>A global record where much <strong class="pkg">YAGS</strong>-related information is stored. This is intended for internal use, and much of this information is undocumented, but some of the data stored here could possibly be useful for advanced users.</p>

<p>However, storing user information in this record and/or changing the values of the stored information is discouraged and may produce unpredictable results and an unstable system.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">YAGSInfo;</span>
rec( Arch := 1, DataDirectory := "/opt/gap-4.10.2/pkg/yags/data", 
  Directory := "/opt/gap-4.10.2/pkg/yags", 
  Draw := 
    rec( opts := [  ], 
      prog := "/opt/gap-4.10.2/pkg/yags/bin/draw/application.linux64/draw" ), 
  InfoClass := YAGSInfoClass, InfoOutput := "*stdout*", Version := "0.0.6",
  graph6 := rec( BinListToNum := function( L ) ... end,
      BinListToNumList := function( L ) ... end,
      HararyList := [ [ 1, 0, 1 ], [ 2, 0, 1 ], [ 2, 1, 1 ],
          [ 3, 0, 1 ], [ 3, 1, 1 ], [ 3, 2, 1 ], [ 3, 3, 1 ],
          [ 4, 0, 1 ], [ 4, 1, 1 ], [ 4, 2, 1 ], [ 4, 3, 3 ],
          [ 4, 2, 2 ], [ 4, 3, 1 ], [ 4, 3, 2 ], [ 4, 4, 1 ],
	  
   --- many more lines here ---
   
          [ 6, 13, 1 ], [ 6, 11, 7 ], [ 6, 11, 9 ], [ 6, 11, 8 ],
          [ 6, 12, 4 ], [ 6, 12, 5 ], [ 6, 13, 2 ], [ 6, 14, 1 ],
          [ 6, 15, 1 ] ], McKayN := function( n ) ... end,
      McKayR := function( L ) ... end,
      NumListToString := function( L ) ... end,
      NumToBinList := function( n ) ... end,
      PadLeftnSplitList6 := function( L ) ... end,
      PadRightnSplitList6 := function( L ) ... end,
      StringToBinList := function( Str ) ... end ) )
</pre></div>

<p><a id="X8602312E8239A2C0" name="X8602312E8239A2C0"></a></p>

<h5>B.24-3 YAGSInfo.InfoClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YAGSInfo.InfoClass</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p><strong class="pkg">YAGS</strong> uses the <a href="/opt/gap-4.10.2/doc/ref/chap7.html#X7B2ADC37783104B9"><span class="RefLink">Reference: InfoLevel</span></a> mechanism in some algorithms for progress reporting. This is useful in algorithms that may take a lot of time to finish, so the user is informed about how much work is already done and how much work remains to be done; this way, the user can decide whether to wait for the response or not.</p>

<p>Enabling and disabling progress reporting is done by changing the <code class="code">InfoLevel</code> of <code class="code">YAGSInfo.InfoClass</code> to the appropriate level. The default <code class="code">InfoLevel</code> for <code class="code">YAGSInfo.InfoClass</code> is 0, and some of <strong class="pkg">YAGS</strong> algorithms report at <code class="code">InfoLevel</code> 1, and others at <code class="code">InfoLevel</code> 3.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(YAGSInfo.InfoClass,3);           </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FullMonoMorphisms(PathGraph(3),CycleGraph(3));</span>
#I [  ]
#I [ 1 ]
#I [ 1, 2 ]
#I [ 1, 3 ]
#I [ 2 ]
#I [ 2, 1 ]
#I [ 2, 3 ]
#I [ 3 ]
#I [ 3, 1 ]
#I [ 3, 2 ]
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(YAGSInfo.InfoClass,0);           </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FullMonoMorphisms(PathGraph(3),CycleGraph(3));</span>
[  ]
</pre></div>

<p>The algorithms that report progress at <code class="code">InfoLevel</code> 1 are <code class="func">ParedGraph</code> (<a href="chapB.html#X7C3B877A84E18B53"><span class="RefLink">B.16-4</span></a>) and <code class="func">Cliques</code> (<a href="chapB.html#X7AA94AAB7961CEC0"><span class="RefLink">B.3-7</span></a>), and also the algorithms that use those, namely: <code class="func">CliqueGraph</code> (<a href="chapB.html#X80671C3A7AAF7B3F"><span class="RefLink">B.3-5</span></a>), <code class="func">CliqueNumber</code> (<a href="chapB.html#X78427A8B81FEB457"><span class="RefLink">B.3-6</span></a>), <code class="func">CompletelyParedGraph</code> (<a href="chapB.html#X7839FF457E264FE1"><span class="RefLink">B.3-12</span></a>), <code class="func">IsCliqueGated</code> (<a href="chapB.html#X78F70A8B7C72464C"><span class="RefLink">B.9-10</span></a>) and <code class="func">NumberOfCliques</code> (<a href="chapB.html#X83ADC7C07E618A7B"><span class="RefLink">B.14-3</span></a>).</p>

<p>The algorithms that report at <code class="code">InfoLevel</code> 3 are <code class="func">Backtrack</code> (<a href="chapB.html#X86C78160854C7F30"><span class="RefLink">B.2-1</span></a>) and the algorithms that use that one, namely: <code class="func">BacktrackBag</code> (<a href="chapB.html#X7A625FDE7D726FAB"><span class="RefLink">B.2-2</span></a>), <code class="func">CompletesOfGivenOrder</code> (<a href="chapB.html#X7C0053187FFA2F57"><span class="RefLink">B.3-14</span></a>), <code class="func">Orientations</code> (<a href="chapB.html#X7B386D5B7E8A9E00"><span class="RefLink">B.15-4</span></a>) and all the morphism-related operations in Chapter <a href="chap5.html#X7AB9CE86793A0114"><span class="RefLink">5</span></a>. The meaning of the progress strings reported in all these functions are described in Section <a href="chap6.html#X7F9CE7A87E7B0111"><span class="RefLink">6.4</span></a>.</p>

<p>The output of the progress info may be redirected to a file or character device by setting the variable <code class="func">YAGSInfo.InfoOutput</code> (<a href="chapB.html#X837885A8851D670D"><span class="RefLink">B.24-4</span></a>) accordingly.</p>

<p><a id="X837885A8851D670D" name="X837885A8851D670D"></a></p>

<h5>B.24-4 YAGSInfo.InfoOutput</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YAGSInfo.InfoOutput</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>The output of the progress info reported by some algorithms (see <code class="func">YAGSInfo.InfoClass</code> (<a href="chapB.html#X8602312E8239A2C0"><span class="RefLink">B.24-3</span></a>)) may be redirected to a file by setting the variable <code class="code">YAGSInfo.InfoOutput</code> accordingly. The default value of <code class="code">YAGSInfo.InfoOutput:="*stdout*"</code> means the console; but setting the name of a file as the value of <code class="code">YAGSInfo.InfoOutput</code> sends the output to that file. In Unix-like systems, we can also use the name of a character device (like <code class="code">"/dev/null"</code>, <code class="code">"/dev/tty"</code> or <code class="code">"/dev/pts/1"</code>) to redirect the progress info output to that device.</p>

<p><a id="X7C665D6881B1291F" name="X7C665D6881B1291F"></a></p>

<h5>B.24-5 YAGSPositionsTrueBlist</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; YAGSPositionsTrueBlist</code>( <var class="Arg">Blist</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For internal use. The same as <code class="code">ListBlist([1..Length(<var class="Arg">Blist</var>)],<var class="Arg">Blist</var>);</code></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">YAGSPositionsTrueBlist([false, true, true, false, true]);</span>
[ 2, 3, 5 ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chapA.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapC.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapA.html">A</a>  <a href="chapB.html">B</a>  <a href="chapC.html">C</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
