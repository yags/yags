algebraic.gd:#O  GroupGraph( <G>, <Grp>, <act> )
algebraic.gd:#O  GroupGraph( <G>, <Grp> )
algebraic.gd:#O  CayleyGraph( <Grp>, <elms> )
algebraic.gd:#O  CayleyGraph( <Grp> )
algebraic.gd:#O  RingGraph( <Rng>, <elms> )
algebraic.gd:#O  Circulant( <n>, <jumps> )
algebraic.gd:#O  CuadraticRingGraph( <Rng> )
algebraic.gd:#O  UnitsRingGraph( <Rng> )
algebraic.gi:#M  GroupGraph( <G>, <Grp>, <act> )
algebraic.gi:#M  GroupGraph( <G>, <Grp> )
algebraic.gi:#M  CayleyGraph( <Grp>, <elms> )
algebraic.gi:#M  CayleyGraph( <Grp> )
algebraic.gi:#M  RingGraph( <Rng>, <elms> )
algebraic.gi:#M  Circulant( <n>, <jumps> )
algebraic.gi:#M  CuadraticRingGraph( <Rng> )
algebraic.gi:#M  UnitsRingGraph( <Rng> )
backtrack.gd:#O  BackTrack( <L>, <opts>, <chk>, <done>, <extra> )
backtrack.gd:#0  BackTrackBag( <opts>, <chk>, <done>, <extra> )
backtrack.gi:#M  BackTrackBag( <opts>, <chk>, <done>, <extra> )
backtrack.gi:#M  BackTrack( <L>, <opts>, <chk>, <done>, <extra> )
backtrack.gi:#InstallOtherMethod(BackTrack,"backtrack: <opts> is list",true, 
backtrack.gi:#[IsList,IsList,IsFunction,IsObject,IsObject],0,
backtrack.gi:#function(L,opts,chk,done,extra)
backtrack.gi:#end); 
backtrack.gi:#This is a more efficient method when opts is a list.
backtrack.gi:#This is an even more efficient method when opts is a list and 
basics.gd:#F  IsBoolean( <O> )
basics.gd:#O  DumpObject( <O> )
basics.gd:#F  DeclareQtfyProperty( <N>, <F> )
basics.gi:#F  IsBoolean( <x> )
basics.gi:#M  DumpObject( <Obj> )
binaryop.gd:#O  BoxProduct( <G>, <H> );
binaryop.gd:#O  TimesProduct( <G>, <H> )
binaryop.gd:#O  BoxTimesProduct( <G>, <H> )
binaryop.gd:#O  DisjointUnion( <G>, <H> )
binaryop.gd:#O  Join( <G>, <H> )
binaryop.gd:#O  GraphSum( <G>, <L> )
binaryop.gd:#O  Composition( <G>, <H> )
binaryop.gi:#M  BoxProduct( <G>, <H> )
binaryop.gi:#M  TimesProduct( <G>, <H> )
binaryop.gi:#M  BoxTimesProduct( <G>, <H> )
binaryop.gi:#M  Union( <G>, <H> )#FIXME: Union is a function in gap!
binaryop.gi:#M  DisjointUnion( <G>, <H> )
binaryop.gi:#M  Join( <G>, <H> )
binaryop.gi:#M  GraphSum( <G>, <L> )
binaryop.gi:#M  Composition( <G>, <H> )
classes.gd:#O  IsDiamondFree( <G>, <qtfy> )
classes.gi:#M  IsDiamondFree( <G>, <qtfy> )
cliques.gd:#A  CliqueNumber( <G> )  
cliques.gd:#Q  IsCliqueHelly( <G> )
cliques.gd:#A  CliqueGraph( <G> )
cliques.gd:#O  CliqueGraph( <G>, <m> )
cliques.gd:#A  Cliques( <G> )
cliques.gd:#O  Cliques( <G>, <m> )
cliques.gd:#A  NumberOfCliques( <G> )
cliques.gd:#O  NumberOfCliques( <G>, <m> )
cliques.gd:#O  Basement( <G>, <KnG>, <x> )
cliques.gd:#O  Basement( <G>, <KnG>, <V> )
cliques.gd:#O  CompletesOfGivenOrder( <G>, <o> )
cliques.gd:#O  IsCliqueGated( <G>, <qtfy> )
cliques.gi:#M  CliqueNumber( <G> )
cliques.gi:#M  IsCliqueHelly( <G>, <qtfy> )
cliques.gi:#M  CliqueGraph( <G> )
cliques.gi:#M  CliqueGraph( <G>, <MaxNumCli> )
cliques.gi:#M  Cliques( <G> )
cliques.gi:#M  Cliques( <G>, <MaxNumCli> )
cliques.gi:#M  NumberOfCliques( <G> )
cliques.gi:#M  NumberOfCliques( <G>, <MaxNumCli> )
cliques.gi:#M  Basement( <G>, <KnG>, <x> )
cliques.gi:#M  Basement( <G>, <KnG>, <V> )
cliques.gi:#M  CompletesOfGivenOrder( <G>, <Ord> )
cliques.gi:#M  IsCliqueGated( <G>, <qtfy> )
digraphs.gd:#O  InNeigh( <G>, <v> )
digraphs.gd:#O  OutNeigh( <G>, <v> )
digraphs.gd:#O  IsTournament( <G> )
digraphs.gd:#O  IsTransitiveTournament( <G> )
digraphs.gi:#M  InNeigh( <G>, <v> )
digraphs.gi:#M  OutNeigh( <G>, <v> )
digraphs.gi:#M  IsTournament( <G> ) 
digraphs.gi:#M  IsTransitiveTournament( <G> ) 
distances.gd:#A  DistanceMatrix( <G> )
distances.gd:#A  Diameter( <G> )
distances.gd:#A  Radius( <G> )
distances.gd:#O  Distance( <G>, <x>, <y> )
distances.gd:#O  Distances( <G>, <A>, <B> )
distances.gd:#O  DistanceSet( <G>, <A>, <B> )
distances.gd:#O  DistanceGraph( <G>, <D> )
distances.gd:#O  PowerGraph( <G>, <e> )
distances.gd:#F  Excentricity( <G>, <x> )
distances.gi:#M  DistanceMatrix( <G> )
distances.gi:#M  Diameter( <G> )
distances.gi:#M  Radius( <G> )
distances.gi:#M  Distance( <G>, <x>, <y> )
distances.gi:#M  Distances( <G>, <A>, <B> )
distances.gi:#M  DistanceSet( <G>, <A>, <B> )
distances.gi:#M  DistanceGraph( <G>, <Dist> )
distances.gi:#M  PowerGraph( <G>, <exp> )
distances.gi:#F  Excentricity( <G>, <x> )
draw.gd:#FIXME: Find a robust, documented way of doing this. Perhaps in PackageInfo?
draw.gd:#finding path of external program 'draw':
draw.gd:#O  SetCoordinates(<G>,<Coord>) 
draw.gd:#O  Coordinates(<G>)
draw.gd:#O  GraphToRaw(<filename>, <G>)
draw.gd:#O  GraphUpdateFromRaw(<filename>,<G>)
draw.gd:#FIXME: write "RawToGraph(filename)"
draw.gd:#O  Draw(<G>)
draw.gi:#M  SetCoordinates(<G>,<Coord>) 
draw.gi:#Minimal verification!
draw.gi:#FIXME: Verify more conditions
draw.gi:#M  Coordinates(<G>) 
draw.gi:#M  GraphToRaw(<filename>, <G>)
draw.gi:#M  GraphUpdateFromRaw(<filename>,<G>)
draw.gi:#M  Draw(<G>)
families.gd:#F  DiscreteGraph( <n> )
families.gd:#F  CompleteGraph( <n> )
families.gd:#F  PathGraph( <n> )
families.gd:#F  CycleGraph( <n> )
families.gd:#F  CubeGraph( <n> )
families.gd:#F  OctahedralGraph( <n> )
families.gd:#F  JohnsonGraph( <n>, <r> )
families.gd:#F  CompleteBipartiteGraph( <n>, <m> )
families.gd:#F  CompleteMultipartiteGraph( <n1>, <n2> [, <n3> ...] )
families.gd:#F  RandomGraph( <n>, <p> )
families.gd:#F  RandomGraph( <n> )
families.gd:#F  CylinderGraph( <Base>, <Height> )
families.gd:#O  WheelGraph( <N> )
families.gd:#O  WheelGraph( <N>, <Radius> )
families.gd:#F  FanGraph( <N> )
families.gd:#F  SunGraph( <N> )
families.gd:#F  SpikyGraph( <N> )
families.gd:#V  TrivialGraph
families.gd:#V  DiamondGraph
families.gd:#V  ClawGraph
families.gd:#V  PawGraph
families.gd:#V  HouseGraph
families.gd:#V  BullGraph
families.gd:#V  AntennaGraph
families.gd:#V  KiteGraph
families.gd:#V  DartGraph
families.gd:#V  ChairGraph
families.gd:#V  GemGraph
families.gd:#V  AGraph
families.gd:#V  DominoGraph
families.gd:#V  ParapluieGraph
families.gd:#V  ParachuteGraph
families.gd:#V  FishGraph
families.gd:#V  RGraph
families.gd:#V  Tetrahedron
families.gd:#V  Octahedron
families.gd:#V  Cube
families.gd:#V  Icosahedron
families.gd:#V  Dodecahedron
families.gd:#V  SnubDisphenoid
families.gd~:#F  DiscreteGraph( <n> )
families.gd~:#F  CompleteGraph( <n> )
families.gd~:#F  PathGraph( <n> )
families.gd~:#F  CycleGraph( <n> )
families.gd~:#F  CubeGraph( <n> )
families.gd~:#F  OctahedralGraph( <n> )
families.gd~:#F  JohnsonGraph( <n>, <r> )
families.gd~:#F  CompleteBipartiteGraph( <n>, <m> )
families.gd~:#F  CompleteMultipartiteGraph( <n1>, <n2> [, <n3> ...] )
families.gd~:#F  RandomGraph( <n>, <p> )
families.gd~:#F  RandomGraph( <n> )
families.gd~:#F  CylinderGraph( <Base>, <Height> )
families.gd~:#O  WheelGraph( <N> )
families.gd~:#O  WheelGraph( <N>, <Radius> )
families.gd~:#F  FanGraph( <N> )
families.gd~:#F  SunGraph( <N> )
families.gd~:#F  SpikyGraph( <N> )
families.gd~:#V  TrivialGraph
families.gd~:#V  DiamondGraph
families.gd~:#V  ClawGraph
families.gd~:#V  PawGraph
families.gd~:#V  HouseGraph
families.gd~:#V  BullGraph
families.gd~:#V  AntennaGraph
families.gd~:#V  KiteGraph
families.gd~:#V  Tetrahedron
families.gd~:#V  Octahedron
families.gd~:#V  Cube
families.gd~:#V  Icosahedron
families.gd~:#V  Dodecahedron
families.gd~:#V  SnubDisphenoid
families.gi:#F  DiscreteGraph( <N> )
families.gi:#F  CompleteGraph( <N> )
families.gi:#F  PathGraph( <N> )
families.gi:#F  CycleGraph( <N> )
families.gi:#F  CubeGraph( <n> )
families.gi:#F  OctahedralGraph( <n> )
families.gi:#F  JohnsonGraph( <n>, <r> )
families.gi:#F  CompleteBipartiteGraph( <n>, <m> )
families.gi:#F  CompleteMultipartiteGraph( <n1>, <n2> [, <n3> ...] )
families.gi:#F  RandomGraph( <n>, <p> )
families.gi:#F  CylinderGraph( <Base>, <Height> )
families.gi:#M  WheelGraph( <N> )
families.gi:#M  WheelGraph( <N>, <Radius> )
families.gi:#F  FanGraph( <N> )
families.gi:#F  SunGraph( <N> )
families.gi:#F  SpikyGraph( <N> )
families.gi~:#F  DiscreteGraph( <N> )
families.gi~:#F  CompleteGraph( <N> )
families.gi~:#F  PathGraph( <N> )
families.gi~:#F  CycleGraph( <N> )
families.gi~:#F  CubeGraph( <n> )
families.gi~:#F  OctahedralGraph( <n> )
families.gi~:#F  JohnsonGraph( <n>, <r> )
families.gi~:#F  CompleteBipartiteGraph( <n>, <m> )
families.gi~:#F  CompleteMultipartiteGraph( <n1>, <n2> [, <n3> ...] )
families.gi~:#F  RandomGraph( <n>, <p> )
families.gi~:#F  CylinderGraph( <Base>, <Height> )
families.gi~:#M  WheelGraph( <N> )
families.gi~:#M  WheelGraph( <N>, <Radius> )
families.gi~:#F  FanGraph( <N> )
families.gi~:#F  SunGraph( <N> )
families.gi~:#F  SpikyGraph( <N> )
iso.gd:#O  NextIsoMorphism( <G>, <H>, <morph> );
iso.gd:#O  IsoMorphism( <G>, <H> )
iso.gd:#O  IsoMorphisms( <G>, <H> )
iso.gd:#O  IsIsomorphicGraph( <G>, <H> )
iso.gd:#O  AutomorphismGroup( <G> )
iso.gi:#I  CHQ_ISO( <L>, <extra> ) ... intended for internal use
iso.gi:#M  NextIsoMorphism( <G>, <H>, <morph> )
iso.gi:#M  IsoMorphism( <G>, <H> )
iso.gi:#M  IsoMorphisms( <G>, <H> )
iso.gi:#M  IsIsomorphicGraph( <G>, <H> )
iso.gi:#M  AutomorphismGroup( <G> )
kernel.gd:#1
kernel.gd:#C  Graphs()
kernel.gd:#C  LooplessGraphs()
kernel.gd:#C  UndirectedGraphs()
kernel.gd:#C  OrientedGraphs()
kernel.gd:#C  SimpleGraphs()
kernel.gd:#F              SetDefaultGraphCategory( <C> )
kernel.gd:#F  GraphCategory( [<G>, ... ] );
kernel.gd:#F  TargetGraphCategory( [<G>, ... ] );
kernel.gd:#O  in(<G>,<C>)
kernel.gd:#A  AdjMatrix(<G>)
kernel.gd:#A  Order(<G>)
kernel.gd:#A  Size(<G>)
kernel.gd:#A  VertexNames(<G>)
kernel.gd:#Q  IsCompleteGraph(<G>)
kernel.gd:#Q  IsLoopless(<G>)
kernel.gd:#Q  IsUndirected(<G>)
kernel.gd:#Q  IsOriented(<G>)
kernel.gd:#O  IsSimple(<G>)
kernel.gd:#O  QtfyIsSimple( <G> )
kernel.gd:#O  IsComplete( <G>, <L> )
kernel.gd:#O  Vertices( <G> )
kernel.gd:#O  IsEdge( <G> , <List>)
kernel.gd:#O  Adjacency( <G>, <V> )
kernel.gd:#O  Adjacencies( <G> )
kernel.gd:#O  VertexDegree( <G>, <V> )
kernel.gd:#O  VertexDegrees( <G> )
kernel.gd:#O  MaxDegree( <G> )
kernel.gd:#O  MinDegree( <G> )
kernel.gd:#O  Edges( <G> )
kernel.gd:#O  Graph( <R> )
kernel.gd:#F  GraphByAdjMatrix( <M> )
kernel.gd:#F  GraphByAdjacencies( <A> )
kernel.gd:#F  GraphByCompleteCover( <C> )
kernel.gd:#F  GraphByRelation( <V>, <R> )
kernel.gd:#F  GraphByRelation( <N>, <R> )
kernel.gd:#F  GraphByWalks( <walk1>, <walk2>,...)
kernel.gd:#F  IntersectionGraph( <L> )
kernel.gd:#O  CopyGraph( <G> ) 
kernel.gd:#O  InducedSubgraph( <G>, <V> )
kernel.gd:#O  RemoveVertices( <G>, <V> )
kernel.gd:#O  AddEdges( <G>, <E> )
kernel.gd:#O  RemoveEdges( <G>, <E> )
kernel.gi:#F  SetDefaultGraphCategory( <Catgy> );
kernel.gi:#F  GraphCategory( [, <Graph>, ... ] );
kernel.gi:#F  TargetGraphCategory( [, <Graph>, ... ] );
kernel.gi:#M  PrintObj( <G> )
kernel.gi:#M  ViewObj( <G> )
kernel.gi:#M  DumpObject( <Obj> )
kernel.gi:#M  IsInternallyConsistent( <G> )   ...  For Debugging
kernel.gi:#A  Order( <G> )
kernel.gi:#A  Size( <G> )
kernel.gi:#A  VertexNames( <G> )
kernel.gi:#M  IsCompleteGraph( <G>, <qtfy> )
kernel.gi:#M  IsLoopless( <G>, <qtfy> )
kernel.gi:#M  IsUndirected( <G>, <qtfy> ) 
kernel.gi:#M  IsOriented( <G>, <qtfy> )
kernel.gi:#M  IsSimple( <G> )
kernel.gi:#M  QtfyIsSimple( <G> )
kernel.gi:#M  IsComplete( <G>, <L> )
kernel.gi:#M  Vertices( <G> )
kernel.gi:#M  IsEdge( <G>, <e> )
kernel.gi:#M  Adjacency( <G>, <x> )
kernel.gi:#M  Adjacencies( <G> )
kernel.gi:#M  VertexDegree( <G>, <x> )
kernel.gi:#M  VertexDegrees( <G> )
kernel.gi:#M  MaxDegree( <G> )
kernel.gi:#M  MinDegree( <G> )
kernel.gi:#M  Edges( <G> )
kernel.gi:#M  Graph( <Rec> )
kernel.gi:#F  GraphByAdjMatrix( <M> )
kernel.gi:#F  GraphByAdjacencies( <Adj> )
kernel.gi:#F  GraphByCompleteCover( <Cover> )
kernel.gi:#F  GraphByRelation( <V>, <rel> )
kernel.gi:#F  GraphByRelation( <N>, <rel> )
kernel.gi:#F  GraphByWalks( <walk1>, <walk2>,... )
kernel.gi:#F  IntersectionGraph( <L> )
kernel.gi:#M  CopyGraph( <G> ) 
kernel.gi:#M  InducedSubgraph( <G>, <V> )
kernel.gi:#M  RemoveVertices( <G>, <V> )
kernel.gi:#M  AddEdges( <G>, <Edgs> )
kernel.gi:#M  RemoveEdges( <G>, <Edgs> )
morph.gd:#O  NextPropertyMorphism( <G1>, <G2>, <m>, <c> )
morph.gd:#O  PropertyMorphism( <G1>, <G2>, <c> )
morph.gd:#O  PropertyMorphisms( <G1>, <G2>, <c> )
morph.gi:#M  NextPropertyMorphism( <G1>, <G2>, <morph>, <chks> )
morph.gi:#M  PropertyMorphism( <G1>, <G2>, <chks> )
morph.gi:#M  PropertyMorphisms( <G1>, <G2>, <chks> )
morph_chq.g:#FIXME: mejorar este también (ver abajo)
morph_chq.g:#FIXME: mejorar este usando grados, 
morph_chq.g:#Think:  Morph(K_100,C_4,EPI);
morph_chq.g:#FIXME: write CHQ_FULL function.
operators.g:#M  \=( <G>, <H> )
operators.g:#M  \{\}( <G>, <V> )
operators.g:#M  \+( <G>, <E> )
operators.g:#M  \-( <G>, <VE> )
operators.g:#M  \^( <G>, <N> )
operators.g:#M  \^( <G>, <L> )
operators.gd:#O  \=( <G>, <H> )
operators.gd:#O  \{\}( <G>, <V> )
operators.gd:#O  \+( <G>, <E> )
operators.gd:#O  \-( <G>, <VE> )
operators.gd:#O  \^( <G>, <N> )
operators.gd:#O  \^( <G>, <L> )
operators.gi:#M  \=( <G>, <H> )
operators.gi:#M  \{\}( <G>, <V> )
operators.gi:#M  \+( <G>, <E> )
operators.gi:#M  \-( <G>, <VE> )
operators.gi:#M  \^( <G>, <N> )
operators.gi:#M  \^( <G>, <L> )
unaryop.gd:#O  LineGraph( <G> )
unaryop.gd:#FIXME: Does this make sense outside SimpleGraphs Category?
unaryop.gd:#A  ComplementGraph( <G> )
unaryop.gd:#O  QuotientGraph( <G>, <P> )
unaryop.gd:#O  QuotientGraph( <G>, <L1>, <L2> )
unaryop.gi:#M  LineGraph( <G> )
unaryop.gi:#M  ComplementGraph( <G> )
unaryop.gi:#M  QuotientGraph( <G>, <P> )
unaryop.gi:#M  QuotientGrfaph( <G>, <L1>, <L2>)
